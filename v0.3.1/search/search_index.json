{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"camlhmp","text":"<p>\ud83d\udc2a camlhmp \ud83d\udc2a - Classification through yAML Heuristic Mapping Protocol</p> <p><code>camlhmp</code> is a tool for generating organism typing tools from YAML schemas. Through discussions with Tim Read, we identified a need for a straightforward method to define and manage typing schemas for organisms of interest. YAML was chosen for its simplicity and readability.</p>"},{"location":"#purpose","title":"Purpose","text":"<p>The primary purpose of <code>camlhmp</code> is to provide a framework that enables researchers to independently define typing schemas for their organisms of interest using YAML. This approach facilitates the management and analysis biological data for researchers at any level of experience.</p> <p><code>camlhmp</code> does not supply pre-defined typing schemas. Instead, it equips researchers with the necessary tools to create and maintain their own schemas, ensuring these schemas can easily remain up to date with the latest scientific developments.</p> <p>Finally, the development of <code>camlhmp</code> was driven by a practical need to streamline maintenance of multiple organism typing tools. Managing these tools separately is time-consuming and challenging. <code>camlhmp</code> simplifies this by providing a single framework for each tool.</p>"},{"location":"#documentation-overview","title":"Documentation Overview","text":"<p>Installation Information for installing <code>camlhmp</code> on your system</p> <p>Available Tools A list of available typing tools utilizing <code>camlhmp</code></p> <p>Schema Definition Details about defining schemas for use with <code>camlhmp</code></p> <p>CLI Reference Details about available CLI commands from <code>camlhmp</code></p> <p>API Reference Details about using the <code>camlhmp</code> package in your own code</p> <p>About Information about the development and funding of <code>camlhmp</code></p>"},{"location":"#funding","title":"Funding","text":"<p>Support for this project came (in part) from the Wyoming Public Health Division, and the Center for Applied Pathogen Epidemiology and Outbreak Control (CAPE).</p> <p> </p>"},{"location":"#citing-camlhmp","title":"Citing <code>camlhmp</code>","text":"<p>If you make use of <code>camlhmp</code> in your analysis, please cite the following:</p> <ul> <li> <p>camlhmp Petit III RA, Read TD camlhmp: Classification through yAML Heuristic Mapping Protocol (GitHub) </p> </li> <li> <p>BLAST+ Camacho C, Coulouris G, Avagyan V, Ma N, Papadopoulos J, Bealer K, Madden TL BLAST+: architecture and applications. BMC Bioinformatics 10, 421 (2009) </p> </li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#v100-rpetit3camlhmp-dromedary-202408","title":"v1.0.0 rpetit3/camlhmp \"Dromedary\" 2024/08/??","text":""},{"location":"CHANGELOG/#added","title":"<code>Added</code>","text":"<ul> <li>Added a mkdocs documentation site</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"<code>Fixed</code>","text":"<ul> <li>fixed <code>camlhmp-blast-regions</code> unnecessary debug output</li> <li>fixed test schemas to match the new schema format</li> </ul>"},{"location":"CHANGELOG/#v031-rpetit3camlhmp-maybe-a-cat-20240805","title":"v0.3.1 rpetit3/camlhmp \"Maybe a cat?\" 2024/08/05","text":""},{"location":"CHANGELOG/#fixed_1","title":"<code>Fixed</code>","text":"<ul> <li><code>camlhmp-blast-alleles</code> not having a default value for targets</li> </ul>"},{"location":"CHANGELOG/#v030-rpetit3camlhmp-more-bunnies-and-fewer-baby-birds-20240805","title":"v0.3.0 rpetit3/camlhmp \"More bunnies and fewer baby birds\" 2024/08/05","text":""},{"location":"CHANGELOG/#added_1","title":"<code>Added</code>","text":"<ul> <li><code>camlhmp-blast-alleles</code> command to search alleles in a set of query sequences using BLAST algorithms</li> </ul>"},{"location":"CHANGELOG/#v022-rpetit3camlhmp-even-a-few-baby-birds-20240722","title":"v0.2.2 rpetit3/camlhmp \"Even a few baby birds\" 2024/07/22","text":""},{"location":"CHANGELOG/#fixed_2","title":"<code>Fixed</code>","text":"<ul> <li><code>--version</code> flag now works as expected</li> </ul>"},{"location":"CHANGELOG/#v021-rpetit3camlhmp-and-a-bunch-of-birds-20240722","title":"v0.2.1 rpetit3/camlhmp \"And a bunch of birds\" 2024/07/22","text":""},{"location":"CHANGELOG/#added_2","title":"<code>Added</code>","text":"<ul> <li>version output with schema name and version</li> </ul>"},{"location":"CHANGELOG/#fixed_3","title":"<code>Fixed</code>","text":"<ul> <li>Empty input files will no longer be processed</li> </ul>"},{"location":"CHANGELOG/#v020-rpetit3camlhmp-four-little-bunnies-20240722","title":"v0.2.0 rpetit3/camlhmp \"Four little bunnies\" 2024/07/22","text":""},{"location":"CHANGELOG/#added_3","title":"<code>Added</code>","text":"<ul> <li><code>camlhmp-blast-region</code> command to search full regions of interest using BLAST algorithms</li> <li>added <code>camlhmp_version</code>, <code>schema_version</code>, and <code>params</code> to output files</li> </ul>"},{"location":"CHANGELOG/#v010-rpetit3camlhmp-little-baby-legs-20240430","title":"v0.1.0 rpetit3/camlhmp \"Little baby legs\" 2024/04/30","text":""},{"location":"CHANGELOG/#added_4","title":"<code>Added</code>","text":"<ul> <li><code>camlhmp</code> command to list all available commands</li> <li><code>camlhmp-blast</code> command to search for targets in a set of query sequences using BLAST algorithms</li> <li><code>camlhmp-extract</code> command to extract targets from a set of reference sequences</li> <li><code>excludes</code> field to <code>types</code> section to allow for exclusion of targets from a profile</li> <li>replaced <code>profiles</code> section with <code>types</code> section to better reflect the schema structure</li> <li>output of results for <code>camlhmp-blast</code></li> </ul>"},{"location":"CHANGELOG/#v001-rpetit3camlhmp-not-even-walking-yet-20240424","title":"v0.0.1 rpetit3/camlhmp \"Not even walking yet\" 2024/04/24","text":"<p>This is a development release for getting things on PyPi and Bioconda. Not expected to be stable.</p>"},{"location":"CHANGELOG/#added_5","title":"<code>Added</code>","text":"<ul> <li>basics of camlhmp with a working example using partial SCCmec</li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"about/#naming","title":"Naming","text":"<p>I really wanted to name a tool with \"camel\" in it because they are my wife's favorite animal\ud83d\udc2a and camels also remind me of my friends in Oman!</p> <p>Once it was decided YAML was going to be the format for defining schemas, I immediately was drawn into \"Classification through YAML\", or CAML\", but quickly found out many others had also thought of this (for other use cases). We went through a few other iterations of CAML without any success. Fortunately, Tim Read came through with a clutch save suggested \"Heuristic Mapping Protocol\". So, here we are - camlhmp!</p>"},{"location":"about/#funding","title":"Funding","text":"<p>Support for this project came (in part) from the Wyoming Public Health Division, and the Center for Applied Pathogen Epidemiology and Outbreak Control (CAPE).</p> <p> </p>"},{"location":"about/#citing-camlhmp","title":"Citing <code>camlhmp</code>","text":"<p>If you make use of <code>camlhmp</code> in your analysis, please cite the following:</p> <ul> <li> <p>camlhmp Petit III RA, Read TD camlhmp: Classification through yAML Heuristic Mapping Protocol (GitHub) </p> </li> <li> <p>BLAST+ Camacho C, Coulouris G, Avagyan V, Ma N, Papadopoulos J, Bealer K, Madden TL BLAST+: architecture and applications. BMC Bioinformatics 10, 421 (2009) </p> </li> </ul>"},{"location":"available-tools/","title":"Available Tools","text":"<p>Below is a list of available typing tools utilizing <code>camlhmp</code>. Each tool is designed to analyze specific sequence data and generate a typing profile based on the schema provided.</p> <p>Tip</p> <p>If you've developed a typing tool that utilizes <code>camlhmp</code>, or know of one, we'd love to add it to this list. To do so, open an issue on the camlhmp GitHub repository</p> Tool Organism Description pasty Pseudomonas aeruginosa in silico serogrouping of Pseudomonas aeruginosa isolates pbptyper Streptococcus pneumoniae In silico Penicillin Binding Protein (PBP) typer for Streptococcus pneumoniae assemblies sccmec Staphylococcus aureus A tool for typing SCCmec cassettes in assemblies"},{"location":"installation/","title":"Installation","text":"<p><code>camlhmp</code> is available through PyPI and Bioconda. While you can install it through PyPi, it is recommended to install it through BioConda so that non-Python dependencies are also installed.</p> <pre><code>conda create -n camlhmp -c conda-forge -c bioconda camlhmp\nconda activate camlhmp\ncamlhmp\n</code></pre>"},{"location":"schema/","title":"Schema Reference","text":"<p>The schema structure is designed to be simple and intuitive. Here is a basic skeleton of the expected schema structure:</p> <pre><code>%YAML 1.2\n---\n# metadata: general information about the schema\nmetadata:\n  id: \"\"          # unique identifier for the schema\n  name: \"\"        # name of the schema\n  description: \"\" # description of the schema\n  version: \"\"     # version of the schema\n  curators: []    # A list of curators of the schema\n\n# engine: specifies the computational tools and additional parameters used for sequence\n#         analysis.\nengine:\n  type: \"\"        # The type of tool used to generate the data\n  tool: \"\"        # The tool used to generate the data\n\n# targets: Lists the specific sequence targets such as genes, proteins, or markers that the\n#          schema will analyze. These should be included in the associated sequence query data\ntargets: []\n\n# aliases: groups multiple targets under a common name for easier reference\naliases:\n  - name: \"\"     # name of the alias\n    targets: []  # list of targets that are part of the alias\n\n# types: define specific combinations of targets and aliases to form distinct types\ntypes:\n  - name: \"\"     # name of the profile\n    targets: []  # list of targets (can use aliases) that are part of the profile\n    excludes: [] # list of targets (or aliases) that will automatically fail the type\n</code></pre> <p>From this schema we have a few sections:</p> <ul> <li><code>metadata</code>: general information about the schema</li> <li><code>engine</code>: computational requirements for sequence analysis</li> <li><code>targets</code>: lists the sequence targets such as genes, proteins, or markers</li> <li><code>aliases</code>: groups multiple targets under a common name for easier reference</li> <li><code>profiles</code>: defines combinations of targets and aliases to form typing profiles</li> </ul> <p>Within each section there are additional fields that will be descibed in the next sections.</p>"},{"location":"schema/#metadata","title":"metadata","text":"<p>The <code>metadata</code> section provides general information about the schema. This includes:</p> Field Type Description id string A unique identifier for the schema name string The name of the schema description string A brief description of the schema version string The version of the schema curators list A list of curators of the schema"},{"location":"schema/#engine","title":"engine","text":"<p>The <code>engine</code> section specifies the computational tools used for sequence analysis.</p> Field Type Description type string The type of engine used for analysis tool string The specific tool to be used for the engine"},{"location":"schema/#targets","title":"targets","text":"<p>The <code>targets</code> section lists the specific sequence targets such as genes, proteins, or markers that the schema will analyze. These should be included in the associated sequence query data.</p> Field Type Description targets list A list of targets to be analyzed"},{"location":"schema/#aliases","title":"aliases","text":"<p><code>aliases</code> are a convenient way to group multiple targets under a common name for easier reference.</p> Field Type Description name string The name of the alias targets list A list of targets that are part of the alias"},{"location":"schema/#types","title":"types","text":"<p>The <code>types</code> section defines specific combinations of targets and aliases to form distinct types.</p> Field Type Description name string The name of the profile targets list A list of targets (or aliases) that are part of the type excludes list A list of targets (or aliases) that will automatically fail the type"},{"location":"schema/#example-schema-partial-sccmec-typing","title":"Example Schema: Partial SCCmec Typing","text":"<p>Here is an example of a partial schema for SCCmec typing:</p> <pre><code>%YAML 1.2\n---\n# metadata: general information about the schema\nmetadata:\n  id: \"sccmec_partial\"                                # unique identifier for the schema\n  name: \"SCCmec Typing\"                              # name of the schema\n  description: \"A partial schema for SCCmec typing\"  # description of the schema\n  version: \"0.0.1\"                                     # version of the schema\n  curators:                                          # A list of curators of the schema\n    - \"Robert Petit\"\n\n# engine: specifies the computational tools and additional parameters used for sequence\n#         analysis.\nengine:\n  type: blast   # The type of tool used to generate the data\n  tool: blastn  # The tool used to generate the data\n\n# targets: Lists the specific sequence targets such as genes, proteins, or markers that the\n#          schema will analyze. These should be included in the associated sequence query data\ntargets:\n  - \"ccrA1\"\n  - \"ccrA2\"\n  - \"ccrA3\"\n  - \"ccrB1\"\n  - \"ccrB2\"\n  - \"ccrB3\"\n  - \"IS431\"\n  - \"IS1272\"\n  - \"mecA\"\n  - \"mecI\"\n  - \"mecR1\"\n\n# aliases: groups multiple targets under a common name for easier reference\naliases:\n  - name: \"ccr Type 1\"           # name of the alias\n    targets: [\"ccrA1\", \"ccrB1\"]  # list of targets that are part of the alias\n  - name: \"ccr Type 2\"\n    targets: [\"ccrA2\", \"ccrB2\"]\n  - name: \"ccr Type 3\"\n    targets: [\"ccrA3\", \"ccrB3\"]\n  - name: \"mec Class A\"\n    targets: [\"IS431\", \"mecA\", \"mecR1\", \"mecI\"]\n  - name: \"mec Class B\"\n    targets: [\"IS431\", \"mecA\", \"mecR1\", \"IS1272\"]\n\n# types: define specific combinations of targets and aliases to form distinct types\ntypes:\n  - name: \"I\"          # name of the profile\n    targets:           # list of targets (can use aliases) that are part of the profile\n      - \"ccr Type 1\"\n      - \"mec Class B\"\n  - name: \"II\"\n    targets:\n      - \"ccr Type 2\"\n      - \"mec Class A\"\n  - name: \"III\"\n    targets:\n      - \"ccr Type 3\"\n      - \"mec Class A\"\n  - name: \"IV\"\n    targets:\n      - \"ccr Type 2\"\n      - \"mec Class B\"\n</code></pre> <p>From this schema, <code>camlhmp</code> can generate a typing tool that can be used to analyze input assemblies. This is only a partial schema, as there are many more SCCmec types and subtypes. But using this schema it should be straight forward to add additional targets and profiles.</p>"},{"location":"api/","title":"camlhmp API Reference","text":"<p>At it's core <code>camlhmp</code> is a library that provides a set of functions for typing organisms. It includes functions for running programs and parsing their outputs. In situations where the available CLI commands do not meet your needs, you can use the API functions to build your own custom workflows.</p> <p>Currently the following modules are available in the <code>camlhmp</code> API:</p> Type Module Function Description Engine camlhmp.engines.blast run_blast Run BLAST program Engine camlhmp.engines.blast run_blast Alias for <code>run_blast</code> with <code>blastn</code> specified Engine camlhmp.engines.blast run_blast Alias for <code>run_blast</code> with <code>tblastn</code> specified Parser camlhmp.parsers.blast get_blast_allele_hits Parse BLAST output for allele hits Parser camlhmp.parsers.blast get_blast_region_hits Parse BLAST output for region hits parser camlhmp.parsers.blast get_blast_target_hits Parse BLAST output for target hits"},{"location":"api/engines/blast/","title":"<code>camlhmp.engines.blast</code>","text":"<p>Below are the functions available in the <code>camlhmp.engines.blast</code> module.</p>"},{"location":"api/engines/blast/#camlhmp.engines.blast.run_blast","title":"<code>camlhmp.engines.blast.run_blast(engine, subject, query, min_pident, min_coverage)</code>","text":"<p>Query sequences against a input subject using BLAST+.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>str</code> <p>The BLAST engine to use</p> required <code>subject</code> <code>str</code> <p>The subject database (input)</p> required <code>query</code> <code>str</code> <p>The query file (targets)</p> required <code>min_pident</code> <code>float</code> <p>The minimum percent identity to count a hit</p> required <code>min_coverage</code> <code>int</code> <p>The minimum percent coverage to count a hit</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>The parsed BLAST results, raw blast results, and stderr</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from camlhmp.engines.blast import run_blast\n&gt;&gt;&gt; run_blast(\"blastn\", \"subject.fasta\", \"query.fasta\", 95, 95)\n</code></pre> Source code in <code>camlhmp/engines/blast.py</code> <pre><code>def run_blast(engine: str, subject: str, query: str, min_pident: float, min_coverage: int) -&gt; list:\n    \"\"\"\n    Query sequences against a input subject using BLAST+.\n\n    Args:\n        engine (str): The BLAST engine to use\n        subject (str): The subject database (input)\n        query (str): The query file (targets)\n        min_pident (float): The minimum percent identity to count a hit\n        min_coverage (int): The minimum percent coverage to count a hit\n\n    Returns:\n        list: The parsed BLAST results, raw blast results, and stderr\n\n    Examples:\n        &gt;&gt;&gt; from camlhmp.engines.blast import run_blast\n        &gt;&gt;&gt; run_blast(\"blastn\", \"subject.fasta\", \"query.fasta\", 95, 95)\n    \"\"\"\n    outfmt = \" \".join(BLASTN_COLS)\n    cat_type = \"zcat\" if str(subject).endswith(\".gz\") else \"cat\"\n    qcov_hsp_perc = f\"-qcov_hsp_perc {min_coverage}\" if min_coverage else \"\"\n    perc_identity = f\"-perc_identity {min_pident}\" if min_pident and engine != \"tblastn\" else \"\"\n    stdout, stderr = execute(\n        f\"{cat_type} {subject} | {engine} -query {query} -subject - -outfmt '6 {outfmt}' {qcov_hsp_perc} {perc_identity}\",\n        capture=True,\n    )\n\n    # Convert BLAST results to a list of dicts\n    results = []\n    target_hits = []\n    for line in stdout.split(\"\\n\"):\n        if line == \"\":\n            continue\n        cols = line.split(\"\\t\")\n        results.append(dict(zip(BLASTN_COLS, cols)))\n        target_hits.append(cols[0])\n\n    if not results:\n        # Create an empty dict if no results are found\n        results.append(dict(zip(BLASTN_COLS, [\"NO_HITS\"] * len(BLASTN_COLS))))\n\n    return [target_hits, results, stderr]\n</code></pre>"},{"location":"api/engines/blast/#camlhmp.engines.blast.run_blastn","title":"<code>camlhmp.engines.blast.run_blastn(subject, query, min_pident, min_coverage)</code>","text":"<p>Query sequences against a input subject using BLASTN.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject database (input)</p> required <code>query</code> <code>str</code> <p>The query file (targets)</p> required <code>min_pident</code> <code>float</code> <p>The minimum percent identity to count a hit</p> required <code>min_coverage</code> <code>int</code> <p>The minimum percent coverage to count a hit</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>The parsed BLAST results, raw blast results, and stderr</p> Source code in <code>camlhmp/engines/blast.py</code> <pre><code>def run_blastn(subject: str, query: str, min_pident: float, min_coverage: int) -&gt; list:\n    \"\"\"\n    Query sequences against a input subject using BLASTN.\n\n    Args:\n        subject (str): The subject database (input)\n        query (str): The query file (targets)\n        min_pident (float): The minimum percent identity to count a hit\n        min_coverage (int): The minimum percent coverage to count a hit\n\n    Returns:\n        list: The parsed BLAST results, raw blast results, and stderr\n    \"\"\"\n    return run_blast(\"blastn\", subject, query, min_pident, min_coverage)\n</code></pre>"},{"location":"api/engines/blast/#camlhmp.engines.blast.run_tblastn","title":"<code>camlhmp.engines.blast.run_tblastn(subject, query, min_pident, min_coverage)</code>","text":"<p>Query sequences against a input subject using TBLASTN.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject database (input)</p> required <code>query</code> <code>str</code> <p>The query file (targets)</p> required <code>min_pident</code> <code>float</code> <p>The minimum percent identity to count a hit</p> required <code>min_coverage</code> <code>int</code> <p>The minimum percent coverage to count a hit</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>The parsed BLAST results, raw blast results, and stderr</p> Source code in <code>camlhmp/engines/blast.py</code> <pre><code>def run_tblastn(subject: str, query: str, min_pident: float, min_coverage: int) -&gt; list:\n    \"\"\"\n    Query sequences against a input subject using TBLASTN.\n\n    Args:\n        subject (str): The subject database (input)\n        query (str): The query file (targets)\n        min_pident (float): The minimum percent identity to count a hit\n        min_coverage (int): The minimum percent coverage to count a hit\n\n    Returns:\n        list: The parsed BLAST results, raw blast results, and stderr\n    \"\"\"\n    return run_blast(\"tblastn\", subject, query, min_pident, min_coverage)\n</code></pre>"},{"location":"api/parsers/blast/","title":"<code>camlhmp.parsers.blast</code>","text":"<p>Below are the functions available in the <code>camlhmp.parsers.blast</code> module.</p>"},{"location":"api/parsers/blast/#camlhmp.parsers.blast.get_blast_allele_hits","title":"<code>camlhmp.parsers.blast.get_blast_allele_hits(targets, results, min_pident, min_coverage)</code>","text":"<p>Find the allele hits in the BLAST results.</p> <p>Parameters:</p> Name Type Description Default <code>targets</code> <code>dict</code> <p>The list of target sequences {id: len(seq)}</p> required <code>results</code> <code>list of dict</code> <p>The BLAST results</p> required <code>min_pident</code> <code>float</code> <p>The minimum percent identity to count a hit</p> required <code>min_coverage</code> <code>int</code> <p>The minimum percent coverage to count a hit</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The allele hits</p> Source code in <code>camlhmp/parsers/blast.py</code> <pre><code>def get_blast_allele_hits(\n    targets: dict, results: dict, min_pident: float, min_coverage: int\n) -&gt; dict:\n    \"\"\"\n    Find the allele hits in the BLAST results.\n\n    Args:\n        targets (dict): The list of target sequences {id: len(seq)}\n        results (list of dict): The BLAST results\n        min_pident (float): The minimum percent identity to count a hit\n        min_coverage (int): The minimum percent coverage to count a hit\n\n    Returns:\n        dict: The allele hits\n    \"\"\"\n    # Aggregate the hits for each target\n    target_results = {}\n\n    for result in results:\n        # Only process real hits\n        if result[\"qseqid\"] != \"NO_HITS\":\n            target, allele = result[\"qseqid\"].rsplit(\"_\", 1)\n            if target not in target_results:\n                target_results[target] = {\n                    \"known\": [],\n                    \"novel\": [],\n                }\n\n            # only process hits that meet minimum criteria\n            if float(result[\"pident\"]) &gt;= min_pident and int(result[\"qcovs\"]) &gt;= min_coverage:\n                # hits that meet requirements\n\n                # Default to \"NEW\" allele, if perfect match use the allele ID\n                final_allele = \"NEW\"\n                final_type = \"novel\"\n                if float(result[\"pident\"]) == 100 and int(result[\"qcovs\"]) == 100:\n                    final_allele = allele\n                    final_type = \"known\"\n\n                target_results[target][final_type].append({\n                        \"id\": final_allele,\n                        \"qcovs\": result[\"qcovs\"],\n                        \"pident\": float(result[\"pident\"]),\n                        \"bitscore\": result[\"bitscore\"],\n                })\n\n    final_allele_hits = {}\n    for target in targets:\n        final_allele_hits[target] = {\n            \"id\": \"-\",\n            \"qcovs\": 0,\n            \"pident\": 0,\n            \"bitscore\": 0,\n            \"comment\": \"No hits met thresholds\",\n        }\n\n    for target in target_results:\n        if len(target_results[target][\"known\"]):\n            # exact matches to known alleles were found\n            if len(target_results[target][\"known\"]) == 1:\n                final_allele_hits[target] = target_results[target][\"known\"][0]\n                final_allele_hits[target][\"comment\"] = \"\"\n            else:\n                # multiple hits\n                final_alleles = []\n                for hit in target_results[target][\"known\"]:\n                    final_alleles.append(hit[\"id\"])\n\n                final_allele_hits[target] = target_results[target][\"known\"][0]\n                final_allele_hits[target][\"id\"] = \",\".join(final_alleles)\n                final_allele_hits[target][\"comment\"] = \"Exact matches to multiple alleles\"\n        elif len(target_results[target][\"novel\"]):\n            # no exact matches to known alleles were found, but thresholds were met\n\n            # report the top scores\n            if len(target_results[target][\"novel\"]) == 1:\n                final_allele_hits[target] = target_results[target][\"novel\"][0]\n                final_allele_hits[target][\"comment\"] = \"\"\n            else:\n                # multiple hits, only report highest score\n                final_allele_hits[target] = sorted(target_results[target][\"novel\"], key=lambda x: x[\"bitscore\"], reverse=True)[0]\n                final_allele_hits[target][\"comment\"] = \"No exact matches to known alleles\"\n\n    # Debugging information\n    logging.debug(\"camlhmp.engines.blast.get_blast_allele_hits\")\n    logging.debug(f\"Allele Hits: {final_allele_hits}\")\n\n    return final_allele_hits\n</code></pre>"},{"location":"api/parsers/blast/#camlhmp.parsers.blast.get_blast_region_hits","title":"<code>camlhmp.parsers.blast.get_blast_region_hits(targets, results, min_pident, min_coverage)</code>","text":"<p>Aggregate multiple target hits for a region from the BLAST results.</p> <p>Parameters:</p> Name Type Description Default <code>targets</code> <code>dict</code> <p>The list of target sequences {id: len(seq)}</p> required <code>results</code> <code>list of dict</code> <p>The BLAST results</p> required <code>min_pident</code> <code>float</code> <p>The minimum percent identity to count a hit</p> required <code>min_coverage</code> <code>int</code> <p>The minimum percent coverage to count a hit</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The target hits</p> Source code in <code>camlhmp/parsers/blast.py</code> <pre><code>def get_blast_region_hits(\n    targets: dict, results: dict, min_pident: float, min_coverage: int\n) -&gt; dict:\n    \"\"\"\n    Aggregate multiple target hits for a region from the BLAST results.\n\n    Args:\n        targets (dict): The list of target sequences {id: len(seq)}\n        results (list of dict): The BLAST results\n        min_pident (float): The minimum percent identity to count a hit\n        min_coverage (int): The minimum percent coverage to count a hit\n\n    Returns:\n        dict: The target hits\n    \"\"\"\n    # Aggregate the hits for each target\n    target_results = {}\n    for target, length in targets.items():\n        target_results[target] = {\n            \"hits\": [],\n            \"coverage\": [0] * length,  # Used to calculate coverage across multiple hits\n            \"comment\": [],\n        }\n\n    # Process each blast hit\n    for result in results:\n        # Only process real hits\n        if result[\"qseqid\"] != \"NO_HITS\":\n            # Only keep hits that pass the minimum percent identity\n            if float(result[\"pident\"]) &gt;= min_pident:\n                # Add hit to list of hits\n                target_results[result[\"qseqid\"]][\"hits\"].append(result)\n\n                # Set the coverage to 1 for each base in the hit\n                for i in range(int(result[\"qstart\"]) - 1, int(result[\"qend\"])):\n                    target_results[result[\"qseqid\"]][\"coverage\"][i] += 1\n\n    # Determine coverage for each target\n    final_results = {}\n    for target, vals in target_results.items():\n        final_results[target] = {\n            \"hits\": vals[\"hits\"],\n            \"coverage\": 100\n            * (\n                sum([1 for i in vals[\"coverage\"] if i &gt; 0])\n                / float(len(vals[\"coverage\"]))\n            ),\n            \"comment\": [],\n        }\n        if len(vals[\"hits\"]) &gt; 1:\n            final_results[target][\"comment\"].append(\n                f\"Coverage based on {len(vals['hits'])} hits\"\n            )\n\n        if sum([1 for i in vals[\"coverage\"] if i &gt; 1]):\n            final_results[target][\"comment\"].append(\n                \"There were one or more overlapping hits\"\n            )\n\n    # Debugging information\n    logging.debug(\"camlhmp.engines.blast_region.get_blast_region_hits\")\n    logging.debug(f\"Profile Hits: {final_results}\")\n\n    return final_results\n</code></pre>"},{"location":"api/parsers/blast/#camlhmp.parsers.blast.get_blast_target_hits","title":"<code>camlhmp.parsers.blast.get_blast_target_hits(targets, results)</code>","text":"<p>Find the target hits in the BLAST results.</p> <p>Parameters:</p> Name Type Description Default <code>targets</code> <code>list</code> <p>The list of target sequences</p> required <code>results</code> <code>dict</code> <p>The BLAST results</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The target hits</p> Source code in <code>camlhmp/parsers/blast.py</code> <pre><code>def get_blast_target_hits(targets: list, results: dict) -&gt; dict:\n    \"\"\"\n    Find the target hits in the BLAST results.\n\n    Args:\n        targets (list): The list of target sequences\n        results (dict): The BLAST results\n\n    Returns:\n        dict: The target hits\n    \"\"\"\n    target_hits = {}\n    for target in targets:\n        target_hits[target] = False\n        if target in results:\n            target_hits[target] = True\n\n    # Debugging information\n    logging.debug(\"camlhmp.engines.blast.get_blast_target_hits\")\n    logging.debug(f\"Profile Hits: {target_hits}\")\n\n    return target_hits\n</code></pre>"},{"location":"cli/","title":"camlhmp CLI Reference","text":"<p><code>camlhmp</code> provides a set of command line interface (CLI) commands for typing organisms. These commands are designed to be easy to use and provide a simple way to type organisms using the available engines and schemas.</p> <p>Currently the following commands are available in the <code>camlhmp</code> CLI:</p> Command Description camlhmp-blast-alleles Classify assemblies using BLAST against alleles of a set of genes camlhmp-blast-regions Classify assemblies using BLAST against larger genomic regions camlhmp-blast-targets Classify assemblies using BLAST against individual genes or proteins camlhmp-extract Extract typing targets from a set of reference sequences"},{"location":"cli/camlhmp-blast-alleles/","title":"<code>camlhmp-blast-alleles</code>","text":"<p><code>camlhmp-blast-alleles</code> is a command that allows users to type their samples using a provided schema with BLAST algorithms. This command is useful when the schema is typing specific alleles of a gene or set of genes (e.g. MLST).</p> <pre><code> Usage: camlhmp-blast-alleles [OPTIONS]\n\n \ud83d\udc2a camlhmp-blast-alleles \ud83d\udc2a - Classify assemblies using BLAST against alleles of\n a set of genes\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --input         -i  TEXT     Input file in FASTA format to classify         \u2502\n\u2502                                 [required]                                     \u2502\n\u2502 *  --yaml          -y  TEXT     YAML file documenting the targets and types    \u2502\n\u2502                                 [required]                                     \u2502\n\u2502 *  --targets       -t  TEXT     Query targets in FASTA format [required]       \u2502\n\u2502    --outdir        -o  PATH     Directory to write output [default: ./]        \u2502\n\u2502    --prefix        -p  TEXT     Prefix to use for output files                 \u2502\n\u2502                                 [default: camlhmp]                             \u2502\n\u2502    --min-pident        INTEGER  Minimum percent identity to count a hit        \u2502\n\u2502                                 [default: 95]                                  \u2502\n\u2502    --min-coverage      INTEGER  Minimum percent coverage to count a hit        \u2502\n\u2502                                 [default: 95]                                  \u2502\n\u2502    --force                      Overwrite existing reports                     \u2502\n\u2502    --verbose                    Increase the verbosity of output               \u2502\n\u2502    --silent                     Only critical errors will be printed           \u2502\n\u2502    --version                    Print schema and camlhmp version               \u2502\n\u2502    --help                       Show this message and exit.                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli/camlhmp-blast-alleles/#example-usage","title":"Example Usage","text":"<p>To run <code>camlhmp-blast-alleles</code>, you will need a FASTA file of your input sequences, a YAML file with the schema, and a FASTA file with the targets. Below is an example of how to run <code>camlhmp-blast-alleles</code> using available test data.</p> <pre><code>camlhmp-blast-alleles \\\n    --yaml tests/data/blast/alleles/spn-pbptype.yaml \\\n    --targets tests/data/blast/alleles/spn-pbptype.fasta \\\n    --input tests/data/blast/alleles/SRR2912551.fna.gz\n\nRunning camlhmp with following parameters:\n    --input tests/data/blast/alleles/SRR2912551.fna.gz\n    --yaml tests/data/blast/alleles/spn-pbptype.yaml\n    --targets tests/data/blast/alleles/spn-pbptype.fasta\n    --outdir ./\n    --prefix camlhmp\n    --min-pident 95\n    --min-coverage 95\n\nStarting camlhmp for S. pneumoniae PBP typing...\nRunning tblastn...\nProcessing hits...\nFinal Results...\n                               S. pneumoniae PBP typing\n\u250f\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2513\n\u2503 \u2026 \u2503 \u2026 \u2503 \u2026 \u2503 \u2026 \u2503 \u2026 \u2503 \u2026 \u2503 \u2026 \u2503 \u2026 \u2503 \u2026 \u2503 1\u2026 \u2503 \u2026 \u2503 2\u2026 \u2503 \u2026 \u2503 2\u2026 \u2503 \u2026 \u2503 2\u2026 \u2503 \u2026 \u2503 2\u2026 \u2503 \u2026 \u2503 2\u2026 \u2503\n\u2521\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2529\n\u2502 \u2026 \u2502 \u2026 \u2502 \u2026 \u2502 \u2026 \u2502 \u2026 \u2502 \u2026 \u2502 \u2026 \u2502 \u2026 \u2502 \u2026 \u2502    \u2502 0 \u2502 1\u2026 \u2502 \u2026 \u2502 5\u2026 \u2502   \u2502 2  \u2502 \u2026 \u2502 1\u2026 \u2502 \u2026 \u2502    \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\nWriting outputs...\nFinal predicted type written to ./camlhmp.tsv\ntblastn results written to ./camlhmp.tblastn.tsv\n</code></pre> <p>Note</p> <p>The table printed to STDOUT by <code>camlhmp-blast-alleles</code> has been purposefully truncated for viewing on the docs. It is the same information that that is in {PREFIX}.tsv.</p>"},{"location":"cli/camlhmp-blast-alleles/#output-files","title":"Output Files","text":"<p><code>camlhmp-blast-region</code> will generate three output files:</p> File Name Description <code>{PREFIX}.tsv</code> A tab-delimited file with the predicted type <code>{PREFIX}.blast.tsv</code> A tab-delimited file of all blast hits"},{"location":"cli/camlhmp-blast-alleles/#prefixtsv","title":"{PREFIX}.tsv","text":"<p>The <code>{PREFIX}.tsv</code> file is a tab-delimited file with the predicted type. The columns are:</p> Column Description sample The sample name as determined by <code>--prefix</code> schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis {TARGET}_id The allele ID for a target hit {TARGET}_pident The percent identity of the hit {TARGET}_qcovs The percent coverage of the hit {TARGET}_bitscore The bitscore of the hit {TARGET}_comment A small comment about the hit <p>Below is an example of the <code>{PREFIX}.tsv</code> file:</p> <pre><code>sample  schema  schema_version  camlhmp_version params  1A_id   1A_pident   1A_qcovs    1A_bitscore 1A_comment  2B_id   2B_pident   2B_qcovs    2B_bitscore 2B_comment  2X_id   2X_pident   2X_qcovs    2X_bitscore 2X_comment\ncamlhmp pbptype_partial 0.0.1   0.3.1   min-coverage=95;min-pident=95   23  100.0   100 556     0   100.0   100 567     2   100.0   100 741 \n</code></pre>"},{"location":"cli/camlhmp-blast-alleles/#prefixblasttsv","title":"{PREFIX}.blast.tsv","text":"<p>The <code>{PREFIX}.blast.tsv</code> file is a tab-delimited file of the raw output for all blast hits. The columns are the standard BLAST output with <code>-outfmt 6</code>.</p> <p>Here is an example of the <code>{PREFIX}.blast.tsv</code> file:</p> <pre><code>qseqid  sseqid  pident  qcovs   qlen    slen    length  nident  mismatch    gapopen qstart  qend    sstart  send    evalue  bitscore\n1A_0    NODE_223_length_8196_cov_21.291849  99.638  100 276 8324    276 275 1   0   1   276 1807    2634    0.0 555\n1A_1    NODE_223_length_8196_cov_21.291849  99.638  100 276 8324    276 275 1   0   1   276 1807    2634    0.0 555\n1A_2    NODE_223_length_8196_cov_21.291849  99.275  100 276 8324    276 274 2   0   1   276 1807    2634    0.0 554\n1A_3    NODE_223_length_8196_cov_21.291849  99.275  100 276 8324    276 274 2   0   1   276 1807    2634    0.0 553\n1A_4    NODE_223_length_8196_cov_21.291849  84.420  100 276 8324    276 233 43  0   1   276 1807    2634    3.91e-155   474\n1A_23   NODE_223_length_8196_cov_21.291849  100.000 100 276 8324    276 276 0   0   1   276 1807    2634    0.0 556\n2B_0    NODE_878_length_2854_cov_17.976875  100.000 100 277 2982    277 277 0   0   1   277 1218    2048    0.0 567\n2B_1    NODE_878_length_2854_cov_17.976875  87.365  100 277 2982    277 242 35  0   1   277 1218    2048    3.24e-173   501\n2B_2    NODE_878_length_2854_cov_17.976875  99.278  100 277 2982    277 275 2   0   1   277 1218    2048    0.0 563\n2B_3    NODE_878_length_2854_cov_17.976875  99.639  100 277 2982    277 276 1   0   1   277 1218    2048    0.0 565\n2B_4    NODE_878_length_2854_cov_17.976875  99.639  100 277 2982    277 276 1   0   1   277 1218    2048    0.0 565\n2X_0    NODE_210_length_5085_cov_16.539627  99.721  100 358 5213    358 357 1   0   1   358 3172    2099    0.0 740\n2X_1    NODE_210_length_5085_cov_16.539627  92.179  100 358 5213    358 330 28  0   1   358 3172    2099    0.0 688\n2X_1    NODE_878_length_2854_cov_17.976875  23.797  99  358 2982    395 94  230 17  1   353 915 2012    1.95e-06    45.8\n2X_2    NODE_210_length_5085_cov_16.539627  100.000 100 358 5213    358 358 0   0   1   358 3172    2099    0.0 741\n2X_3    NODE_210_length_5085_cov_16.539627  99.721  100 358 5213    358 357 1   0   1   358 3172    2099    0.0 739\n2X_4    NODE_210_length_5085_cov_16.539627  99.441  100 358 5213    358 356 2   0   1   358 3172    2099    0.0 738\n</code></pre>"},{"location":"cli/camlhmp-blast-alleles/#prefixdetailstsv","title":"{PREFIX}.details.tsv","text":"<p>The <code>{PREFIX}.details.tsv</code> file is a tab-delimited file with details for each type. This file can be useful for seeing how a sample did against all other types in a schema.</p> <p>The columns in this file are:</p> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type status The status of the type (True if failed) targets The targets for the given type that had a match missing The targets for the given type that were not found coverage The coverage of the target region hits The number of hits used to calculate coverage of the target region schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result <p>Below is an example of the <code>{PREFIX}.details.tsv</code> file:</p> <pre><code>sample  type    status  targets missing coverage    hits    schema  schema_version  camlhmp_version params  comment\ncamlhmp O1  False       O1  12.49   2   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   Coverage based on 2 hits\ncamlhmp O2  False   O2  wzyB    100.00,0.00 1,0 pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp O3  False       O3  1.43    1   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp O4  False       O4  13.86   2   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   Coverage based on 2 hits\ncamlhmp O5  True    O2      100.00  1   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre>"},{"location":"cli/camlhmp-blast-regions/","title":"<code>camlhmp-blast-regions</code>","text":"<p><code>camlhmp-blast-regions</code> is a command that allows users to search for full regions of interest. It is nearly identical to <code>camlhmp-blast-targets</code>, but instead of many smaller targets the idea is to instead look at full regions such as O-antigens and or similar features.</p>"},{"location":"cli/camlhmp-blast-regions/#usage","title":"Usage","text":"<pre><code> Usage: camlhmp-blast-regions [OPTIONS]\n\n \ud83d\udc2a camlhmp-blast-regions \ud83d\udc2a - Classify assemblies using BLAST against larger genomic\n regions\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --input         -i  TEXT     Input file in FASTA format to classify [required]   \u2502\n\u2502 *  --yaml          -y  TEXT     YAML file documenting the targets and types         \u2502\n\u2502                                 [required]                                          \u2502\n\u2502 *  --targets       -t  TEXT     Query targets in FASTA format [required]            \u2502\n\u2502    --outdir        -o  PATH     Directory to write output [default: ./]             \u2502\n\u2502    --prefix        -p  TEXT     Prefix to use for output files [default: camlhmp]   \u2502\n\u2502    --min-pident        INTEGER  Minimum percent identity to count a hit             \u2502\n\u2502                                 [default: 95]                                       \u2502\n\u2502    --min-coverage      INTEGER  Minimum percent coverage to count a hit             \u2502\n\u2502                                 [default: 95]                                       \u2502\n\u2502    --force                      Overwrite existing reports                          \u2502\n\u2502    --verbose                    Increase the verbosity of output                    \u2502\n\u2502    --silent                     Only critical errors will be printed                \u2502\n\u2502    --version                    Print schema and camlhmp version                    \u2502\n\u2502    --help                       Show this message and exit.                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli/camlhmp-blast-regions/#example-usage","title":"Example Usage","text":"<p>To run <code>camlhmp-blast-regions</code>, you will need a FASTA file of your input sequences, a YAML file with the schema, and a FASTA file with the targets. Below is an example of how to run <code>camlhmp-blast-regions</code> using available test data.</p> <pre><code>camlhmp-blast-regions \\\n    --yaml tests/data/blast/regions/pseudomonas-serogroup.yaml \\\n    --targets tests/data/blast/regions/pseudomonas-serogroup.fasta \\\n    --input tests/data/blast/regions/O1-GCF_000504045.fna.gz\n\nRunning camlhmp with following parameters:\n    --input tests/data/blast/regions/O1-GCF_000504045.fna.gz\n    --yaml tests/data/blast/regions/pseudomonas-serogroup.yaml\n    --targets tests/data/blast/regions/pseudomonas-serogroup.fasta\n    --outdir ./\n    --prefix camlhmp\n    --min-pident 95\n    --min-coverage 95\n\nStarting camlhmp for Pseudomonas Serogrouping...\nRunning blastn...\nProcessing hits...\nFinal Results...\n                               Pseudomonas Serogrouping\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 sample \u2503 type \u2503 targe\u2026 \u2503 cover\u2026 \u2503 hits \u2503 schema \u2503 schem\u2026 \u2503 camlh\u2026 \u2503 params \u2503 comme\u2026 \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 camlh\u2026 \u2502 O1   \u2502 O1     \u2502 100.00 \u2502 1    \u2502 pseud\u2026 \u2502 0.0.1  \u2502 0.3.1  \u2502 min-c\u2026 \u2502        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nWriting outputs...\nFinal predicted type written to ./camlhmp.tsv\nResults against each type written to ./camlhmp.details.tsv\nblastn results written to ./camlhmp.blastn.tsv\n</code></pre> <p>Note</p> <p>The table printed to STDOUT by <code>camlhmp-blast-regions</code> has been purposefully truncated for viewing on the docs. It is the same information that that is in {PREFIX}.tsv.</p>"},{"location":"cli/camlhmp-blast-regions/#output-files","title":"Output Files","text":"<p><code>camlhmp-blast-region</code> will generate three output files:</p> File Name Description <code>{PREFIX}.tsv</code> A tab-delimited file with the predicted type <code>{PREFIX}.blast.tsv</code> A tab-delimited file of all blast hits <code>{PREFIX}.details.tsv</code> A tab-delimited file with details for each type"},{"location":"cli/camlhmp-blast-regions/#prefixtsv","title":"{PREFIX}.tsv","text":"<p>The <code>{PREFIX}.tsv</code> file is a tab-delimited file with the predicted type. The columns are:</p> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type targets The targets for the given type that had a hit coverage The coverage of the target region hits The number of hits used to calculate coverage of the target region schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result <p>Below is an example of the <code>{PREFIX}.tsv</code> file:</p> <pre><code>sample  type    targets coverage    hits    schema  schema_version  camlhmp_version params  comment\ncamlhmp O5  O2  100.00  1   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre>"},{"location":"cli/camlhmp-blast-regions/#prefixblasttsv","title":"{PREFIX}.blast.tsv","text":"<p>The <code>{PREFIX}.blast.tsv</code> file is a tab-delimited file of the raw output for all blast hits. The columns are the standard BLAST output with <code>-outfmt 6</code>.</p> <p>Here is an example of the <code>{PREFIX}.blast.tsv</code> file:</p> <pre><code>qseqid  sseqid  pident  qcovs   qlen    slen    length  nident  mismatch    gapopen qstart  qend    sstart  send    evalue  bitscore\nwzyB    NZ_PSQS01000003.1   88.403  99  1140    6935329 595 526 69  0   545 1139    6874509 6875103 0.0 717\nwzyB    NZ_PSQS01000003.1   88.403  99  1140    6935329 595 526 69  0   545 1139    6920911 6921505 0.0 717\nwzyB    NZ_PSQS01000003.1   89.444  99  1140    6935329 540 483 56  1   1   539 6872864 6873403 0.0 680\nwzyB    NZ_PSQS01000003.1   89.444  99  1140    6935329 540 483 56  1   1   539 6919266 6919805 0.0 680\nO1  NZ_PSQS01000003.1   97.972  12  18368   6935329 1972    1932    38  2   16398   18368   6620589 6618619 0.0 3419\nO1  NZ_PSQS01000003.1   96.296  12  18368   6935329 324 312 11  1   1   323 6641914 6641591 1.68e-149   531\nO2  NZ_PSQS01000003.1   99.841  100 23303   6935329 23303   23266   30  1   1   23303   6618619 6641914 0.0 42821\nO2  NZ_PSQS01000003.1   86.935  100 23303   6935329 1240    1078    130 12  2542    3749    3864567 3863328 0.0 1363\nO3  NZ_PSQS01000003.1   94.442  13  20210   6935329 2393    2260    114 15  1   2386    6618619 6620999 0.0 3664\nO3  NZ_PSQS01000003.1   99.308  13  20210   6935329 289 287 2   0   19922   20210   6641626 6641914 3.09e-147   523\nO4  NZ_PSQS01000003.1   97.448  14  15279   6935329 1842    1795    47  0   1   1842    6618619 6620460 0.0 3142\nO4  NZ_PSQS01000003.1   99.638  14  15279   6935329 276 275 1   0   15004   15279   6641639 6641914 8.46e-142   505\n</code></pre>"},{"location":"cli/camlhmp-blast-regions/#prefixdetailstsv","title":"{PREFIX}.details.tsv","text":"<p>The <code>{PREFIX}.details.tsv</code> file is a tab-delimited file with details for each type. This file can be useful for seeing how a sample did against all other types in a schema.</p> <p>The columns in this file are:</p> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type status The status of the type (True if failed) targets The targets for the given type that had a match missing The targets for the given type that were not found coverage The coverage of the target region hits The number of hits used to calculate coverage of the target region schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result <p>Below is an example of the <code>{PREFIX}.details.tsv</code> file:</p> <pre><code>sample  type    status  targets missing coverage    hits    schema  schema_version  camlhmp_version params  comment\ncamlhmp O1  False       O1  12.49   2   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   Coverage based on 2 hits\ncamlhmp O2  False   O2  wzyB    100.00,0.00 1,0 pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp O3  False       O3  1.43    1   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp O4  False       O4  13.86   2   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   Coverage based on 2 hits\ncamlhmp O5  True    O2      100.00  1   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre>"},{"location":"cli/camlhmp-blast-regions/#example-implementation","title":"Example Implementation","text":"<p>If you would like to see how <code>camlhmp-blast-regions</code> can be used, please see pasty. In <code>pasty</code> the schema is set up to directly use <code>camlhmp-blast-regions</code> to classify samples without any extra logic.</p> <p>This allows for a simple wrapper like the following:</p> <pre><code>#!/usr/bin/env bash\npasty_dir=$(dirname $0)\n\nCAML_YAML=\"${pasty_dir}/../data/pa-osa.yaml\" \\\nCAML_TARGETS=\"${pasty_dir}/../data/pa-osa.fasta\" \\\n    camlhmp-blast-regions \\\n    \"${@:1}\"\n</code></pre> <p>This script will run <code>camlhmp-blast-regions</code> with the <code>pasty</code> schema and targets.</p>"},{"location":"cli/camlhmp-blast-targets/","title":"<code>camlhmp-blast-targets</code>","text":"<p><code>camlhmp-blast-targets</code> is a command that allows users to type their samples using a provided schema with BLAST algorithms. This command is useful when a schema is looking at full length genes or proteins.</p>"},{"location":"cli/camlhmp-blast-targets/#usage","title":"Usage","text":"<pre><code> Usage: camlhmp-blast-targets [OPTIONS]\n\n \ud83d\udc2a camlhmp-blast-targets \ud83d\udc2a - Classify assemblies using BLAST against individual\n genes or proteins\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --input         -i  TEXT     Input file in FASTA format to classify [required]   \u2502\n\u2502 *  --yaml          -y  TEXT     YAML file documenting the targets and types         \u2502\n\u2502                                 [required]                                          \u2502\n\u2502 *  --targets       -t  TEXT     Query targets in FASTA format [required]            \u2502\n\u2502    --outdir        -o  PATH     Directory to write output [default: ./]             \u2502\n\u2502    --prefix        -p  TEXT     Prefix to use for output files [default: camlhmp]   \u2502\n\u2502    --min-pident        INTEGER  Minimum percent identity to count a hit             \u2502\n\u2502                                 [default: 95]                                       \u2502\n\u2502    --min-coverage      INTEGER  Minimum percent coverage to count a hit             \u2502\n\u2502                                 [default: 95]                                       \u2502\n\u2502    --force                      Overwrite existing reports                          \u2502\n\u2502    --verbose                    Increase the verbosity of output                    \u2502\n\u2502    --silent                     Only critical errors will be printed                \u2502\n\u2502    --version                    Print schema and camlhmp version                    \u2502\n\u2502    --help                       Show this message and exit.                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli/camlhmp-blast-targets/#example-usage","title":"Example Usage","text":"<p>To run <code>camlhmp-blast-targets</code>, you will need a FASTA file of your input sequences, a YAML file with the schema, and a FASTA file with the targets. Below is an example of how to run <code>camlhmp-blast-targets</code> using available test data.</p> <pre><code>camlhmp-blast-targets \\\n    --yaml tests/data/blast/targets/sccmec-partial.yaml \\\n    --targets tests/data/blast/targets/sccmec-partial.fasta \\\n    --input tests/data/blast/targets/sccmec-i.fasta\n\nRunning camlhmp with following parameters:\n    --input tests/data/blast/targets/sccmec-i.fasta\n    --yaml tests/data/blast/targets/sccmec-partial.yaml\n    --targets tests/data/blast/targets/sccmec-partial.fasta\n    --outdir ./\n    --prefix camlhmp\n    --min-pident 95\n    --min-coverage 95\n\nStarting camlhmp for SCCmec Typing...\nRunning blastn...\nProcessing hits...\nFinal Results...\n                                     SCCmec Typing\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 sample  \u2503 type \u2503 targets   \u2503 schema    \u2503 schema_v\u2026 \u2503 camlhmp\u2026 \u2503 params    \u2503 comment \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 camlhmp \u2502 I    \u2502 ccrA1,cc\u2026 \u2502 sccmec_p\u2026 \u2502 0.0.1     \u2502 0.3.1    \u2502 min-cove\u2026 \u2502         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nWriting outputs...\nFinal predicted type written to ./camlhmp.tsv\nResults against each type written to ./camlhmp.details.tsv\nblastn results written to ./camlhmp.blastn.tsv\n</code></pre> <p>Note</p> <p>The table printed to STDOUT by <code>camlhmp-blast-targets</code> has been purposefully truncated for viewing on the docs. It is the same information that that is in {PREFIX}.tsv.</p>"},{"location":"cli/camlhmp-blast-targets/#output-files","title":"Output Files","text":"<p><code>camlhmp-blast-targets</code> will generate three output files:</p> File Name Description <code>{PREFIX}.tsv</code> A tab-delimited file with the predicted type <code>{PREFIX}.blast.tsv</code> A tab-delimited file of all blast hits <code>{PREFIX}.details.tsv</code> A tab-delimited file with details for each type"},{"location":"cli/camlhmp-blast-targets/#prefixtsv","title":"{PREFIX}.tsv","text":"<p>The <code>{PREFIX}.tsv</code> file is a tab-delimited file with the predicted type. The columns are:</p> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type targets The targets for the given type that had a hit schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result <p>Below is an example of the <code>{PREFIX}.tsv</code> file:</p> <pre><code>sample  type    targets schema  schema_version  camlhmp_version params  comment\ncamlhmp I   ccrA1,ccrB1,IS431,IS1272,mecA,mecR1 sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre>"},{"location":"cli/camlhmp-blast-targets/#prefixblasttsv","title":"{PREFIX}.blast.tsv","text":"<p>The <code>{PREFIX}.blast.tsv</code> file is a tab-delimited file of the raw output for all blast hits. The columns are the standard BLAST output with <code>-outfmt 6</code>.</p> <p>Here is an example of the <code>{PREFIX}.blast.tsv</code> file:</p> <pre><code>qseqid  sseqid  pident  qcovs   qlen    slen    length  nident  mismatch    gapopen qstart  qend    sstart  send    evalue  bitscore\nccrA1   AB033763.2  100.000 100 1350    39332   1350    1350    0   0   1   1350    23692   25041   0.0 2494\nccrB1   AB033763.2  100.000 100 1152    39332   1152    1152    0   0   1   1152    25063   26214   0.0 2128\nIS1272  AB033763.2  100.000 100 1659    39332   1659    1659    0   0   1   1659    28423   30081   0.0 3064\nmecR1   AB033763.2  100.000 100 987 39332   987 987 0   0   1   987 30304   31290   0.0 1823\nmecA    AB033763.2  99.950  100 2007    39332   2007    2006    1   0   1   2007    31390   33396   0.0 3701\nmecA    AB033763.2  99.950  100 2007    39332   2007    2006    1   0   1   2007    31390   33396   0.0 3701\nIS431   AB033763.2  99.873  100 790 39332   790 789 1   0   1   790 35958   36747   0.0 1454\nIS431   AB033763.2  100.000 100 792 39332   792 792 0   0   1   792 35957   36748   0.0 1463\n</code></pre>"},{"location":"cli/camlhmp-blast-targets/#prefixdetailstsv","title":"{PREFIX}.details.tsv","text":"<p>The <code>{PREFIX}.details.tsv</code> file is a tab-delimited file with details for each type. This file can be useful for seeing how a sample did against all other types in a schema.</p> <p>The columns in this file are:</p> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type status The status of the type (True if failed) targets The targets for the given type that had a match missing The targets for the given type that were not found schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result <p>Below is an example of the <code>{PREFIX}.details.tsv</code> file:</p> <pre><code>sample  type    status  targets missing schema  schema_version  camlhmp_version params  comment\ncamlhmp I   True    ccrA1,ccrB1,IS431,mecA,mecR1,IS1272     sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp II  False   IS431,mecA,mecR1    ccrA2,ccrB2,mecI    sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp III False   IS431,mecA,mecR1    ccrA3,ccrB3,mecI    sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp IV  False   IS431,mecA,mecR1,IS1272 ccrA2,ccrB2 sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre>"},{"location":"cli/camlhmp-blast-targets/#example-implementation","title":"Example Implementation","text":"<p>If you would like to see how <code>camlhmp-blast-targets</code> can be used, please see sccmec. In <code>sccmec</code> the schema is set up to directly use <code>camlhmp-blast-targets</code> to classify samples without any extra logic.</p> <p>This allows for a simple wrapper like the following:</p> <pre><code>#!/usr/bin/env bash\nsccmec_dir=$(dirname $0)\n\nCAML_YAML=\"${sccmec_dir}/../data/sccmec.yaml\" \\\nCAML_TARGETS=\"${sccmec_dir}/../data/sccmec.fasta\" \\\n    camlhmp-blast-targets \\\n    \"${@:1}\"\n</code></pre> <p>This script will run <code>camlhmp-blast-targets</code> with the <code>sccmec</code> schema and targets.</p>"},{"location":"cli/camlhmp-extract/","title":"Camlhmp extract","text":""},{"location":"cli/camlhmp-extract/#camlhmp-extract","title":"<code>camlhmp-extract</code>","text":"<p><code>camlhmp-extract</code> is a command that allows users to extract targets from a set of references. You should think of this script as a \"helper\" script for curators. It allows you to maintain a TSV file with the targets and their positions in the reference sequences. <code>camlhmp-extract</code> will then extract the targets from the reference sequences and write them to a FASTA file.</p>"},{"location":"cli/camlhmp-extract/#usage","title":"Usage","text":"<pre><code> \ud83d\udc2a camlhmp-extract \ud83d\udc2a - Extract typing targets from a set of reference sequences\n\n\u256d\u2500 Required Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --path     -i  TEXT  The path where input files are located [required]                   \u2502\n\u2502 *  --targets  -t  TEXT  A TSV of targets to extract in FASTA format [required]              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Additional Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --outdir   -o  TEXT  The path to save the extracted targets                                 \u2502\n\u2502 --verbose            Increase the verbosity of output                                       \u2502\n\u2502 --silent             Only critical errors will be printed                                   \u2502\n\u2502 --version  -V        Show the version and exit.                                             \u2502\n\u2502 --help               Show this message and exit.                                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"}]}