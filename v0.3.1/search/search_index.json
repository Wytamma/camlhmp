{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#camlhmp","title":"camlhmp","text":"<p>\ud83d\udc2a camlhmp \ud83d\udc2a - Classification through yAML Heuristic Mapping Protocol</p> <p><code>camlhmp</code> is a tool for generating organism typing tools from YAML schemas. The idea came up from discussions with Tim Read about the need for a tool that would allow researchers to more easily define typing schemas for their organisms of interest. YAML seemed like a a nice format for this due to its simplicity and readability.</p> <p><code>camlhmp</code> is under active development, and any feedback is appreciated.</p>"},{"location":"#purpose","title":"Purpose","text":"<p>The primary purpose of <code>camlhmp</code> is to provide a framework that enables researchers to independently define typing schemas for their organisms of interest using YAML. This facilitates the management and analysis biological data, no matter the researchers experience level.</p> <p><code>camlhmp</code> does not supply any pre-defined typing schemas. Instead, it provides researchers with the tools necessary tools to create and maintain their own schemas. This I believe will ensure the schemas remain up to date with the latest developments in its respective field.</p> <p>Additionally, this really arose from a practical need to streamline my maintenance of multiple organism typing tools. Long-term maintenance of these tools is a challenge, and I think <code>camlhmp</code> will help me to keep them up-to-date and consistent.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>camlhmp</code> will be made available through PyPI and Bioconda. For now, you can install it from the GitHub repository with the following command:</p> <pre><code>conda create -n camlhmp -c conda-forge -c bioconda camlhmp\nconda activate camlhmp\ncamlhmp\n</code></pre>"},{"location":"#yaml-schema-structure","title":"YAML Schema Structure","text":"<p>The schema structure is designed to be simple and intuitive. Here is a basic skeleton of the expected schema structure:</p> <pre><code>%YAML 1.2\n---\n# metadata: general information about the schema\nmetadata:\n  id: \"\"          # unique identifier for the schema\n  name: \"\"        # name of the schema\n  description: \"\" # description of the schema\n  version: \"\"     # version of the schema\n  curators: []    # A list of curators of the schema\n\n# engine: specifies the computational tools and additional parameters used for sequence\n#         analysis.\nengine:\n  tool: \"\" # The tool used to generate the data\n\n# targets: Lists the specific sequence targets such as genes, proteins, or markers that the\n#          schema will analyze. These should be included in the associated sequence query data\ntargets: []\n\n# aliases: groups multiple targets under a common name for easier reference\naliases:\n  - name: \"\"     # name of the alias\n    targets: []  # list of targets that are part of the alias\n\n# types: define specific combinations of targets and aliases to form distinct types\ntypes:\n  - name: \"\"     # name of the profile\n    targets: []  # list of targets (can use aliases) that are part of the profile\n    excludes: [] # list of targets (or aliases) that will automatically fail the type\n</code></pre> <p>From this schema we have a few sections:</p> <ul> <li><code>metadata</code>: general information about the schema</li> <li><code>engine</code>: computational requirements for sequence analysis</li> <li><code>targets</code>: lists the sequence targets such as genes, proteins, or markers</li> <li><code>aliases</code>: groups multiple targets under a common name for easier reference</li> <li><code>profiles</code>: defines combinations of targets and aliases to form typing profiles</li> </ul> <p>Within each section there are additional fields that will be descibed in the next sections.</p>"},{"location":"#metadata","title":"metadata","text":"<p>The <code>metadata</code> section provides general information about the schema. This includes:</p> Field Type Description id string A unique identifier for the schema name string The name of the schema description string A brief description of the schema version string The version of the schema curators list A list of curators of the schema"},{"location":"#engine","title":"engine","text":"<p>The <code>engine</code> section specifies the computational tools used for sequence analysis. Currently only one tool can be specified, and only <code>blastn</code> is supported.</p> Field Type Description tool string The tool used to generate the data"},{"location":"#targets","title":"targets","text":"<p>The <code>targets</code> section lists the specific sequence targets such as genes, proteins, or markers that the schema will analyze. These should be included in the associated sequence query data.</p> Field Type Description targets list A list of targets to be analyzed"},{"location":"#aliases","title":"aliases","text":"<p><code>aliases</code> are a convenient way to group multiple targets under a common name for easier reference.</p> Field Type Description name string The name of the alias targets list A list of targets that are part of the alias"},{"location":"#types","title":"types","text":"<p>The <code>types</code> section defines specific combinations of targets and aliases to form distinct types.</p> Field Type Description name string The name of the profile targets list A list of targets (or aliases) that are part of the type excludes list A list of targets (or aliases) that will automatically fail the type"},{"location":"#example-schema-partial-sccmec-typing","title":"Example Schema: Partial SCCmec Typing","text":"<p>Here is an example of a partial schema for SCCmec typing:</p> <pre><code>%YAML 1.2\n---\n# metadata: general information about the schema\nmetadata:\n  id: \"sccmec_partial\"                                # unique identifier for the schema\n  name: \"SCCmec Typing\"                              # name of the schema\n  description: \"A partial schema for SCCmec typing\"  # description of the schema\n  version: \"0.0.1\"                                     # version of the schema\n  curators:                                          # A list of curators of the schema\n    - \"Robert Petit\"\n\n# engine: specifies the computational tools and additional parameters used for sequence\n#         analysis.\nengine:\n  tool: blastn # The tool used to generate the data\n\n# targets: Lists the specific sequence targets such as genes, proteins, or markers that the\n#          schema will analyze. These should be included in the associated sequence query data\ntargets:\n  - \"ccrA1\"\n  - \"ccrA2\"\n  - \"ccrA3\"\n  - \"ccrB1\"\n  - \"ccrB2\"\n  - \"ccrB3\"\n  - \"IS431\"\n  - \"IS1272\"\n  - \"mecA\"\n  - \"mecI\"\n  - \"mecR1\"\n\n# aliases: groups multiple targets under a common name for easier reference\naliases:\n  - name: \"ccr Type 1\"           # name of the alias\n    targets: [\"ccrA1\", \"ccrB1\"]  # list of targets that are part of the alias\n  - name: \"ccr Type 2\"\n    targets: [\"ccrA2\", \"ccrB2\"]\n  - name: \"ccr Type 3\"\n    targets: [\"ccrA3\", \"ccrB3\"]\n  - name: \"mec Class A\"\n    targets: [\"IS431\", \"mecA\", \"mecR1\", \"mecI\"]\n  - name: \"mec Class B\"\n    targets: [\"IS431\", \"mecA\", \"mecR1\", \"IS1272\"]\n\n# types: define specific combinations of targets and aliases to form distinct types\ntypes:\n  - name: \"I\"          # name of the profile\n    targets:           # list of targets (can use aliases) that are part of the profile\n      - \"ccr Type 1\"\n      - \"mec Class B\"\n  - name: \"II\"\n    targets:\n      - \"ccr Type 2\"\n      - \"mec Class A\"\n  - name: \"III\"\n    targets:\n      - \"ccr Type 3\"\n      - \"mec Class A\"\n  - name: \"IV\"\n    targets:\n      - \"ccr Type 2\"\n      - \"mec Class B\"\n</code></pre> <p>From this schema, <code>camlhmp</code> can generate a typing tool that can be used to analyze input assemblies. This is only a partial schema, as there are many more SCCmec types and subtypes. But using this schema it should be straight forward to add additional targets and profiles.</p>"},{"location":"#camlhmp-blast","title":"<code>camlhmp-blast</code>","text":"<p><code>camlhmp-blast</code> is a command that allows users to type their samples using a provided schema with BLAST algorithms.</p>"},{"location":"#usage","title":"Usage","text":"<pre><code> \ud83d\udc2a camlhmp-blast \ud83d\udc2a - Classify assemblies with a camlhmp schema using BLAST                          \n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502    --version       -V           Show the version and exit.                                  \u2502\n\u2502 *  --input         -i  TEXT     Input file in FASTA format to classify [required]           \u2502\n\u2502 *  --yaml          -y  TEXT     YAML file documenting the targets and types [required]      \u2502\n\u2502 *  --targets       -t  TEXT     Query targets in FASTA format [required]                    \u2502\n\u2502    --outdir        -o  PATH     Directory to write output [default: ./]                     \u2502\n\u2502    --prefix        -p  TEXT     Prefix to use for output files [default: camlhmp]           \u2502\n\u2502    --min-pident        INTEGER  Minimum percent identity to count a hit [default: 95]       \u2502\n\u2502    --min-coverage      INTEGER  Minimum percent coverage to count a hit [default: 95]       \u2502\n\u2502    --force                      Overwrite existing reports                                  \u2502\n\u2502    --verbose                    Increase the verbosity of output                            \u2502\n\u2502    --silent                     Only critical errors will be printed                        \u2502\n\u2502    --help                       Show this message and exit.                                 |\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"#output-files","title":"Output Files","text":"<p><code>camlhmp-blast</code> will generate three output files:</p> File Name Description <code>{PREFIX}.tsv</code> A tab-delimited file with the predicted type <code>{PREFIX}.blast.tsv</code> A tab-delimited file of all blast hits <code>{PREFIX}.details.tsv</code> A tab-delimited file with details for each type"},{"location":"#example-prefixtsv","title":"Example {PREFIX}.tsv","text":"<pre><code>sample  type    targets schema  schema_version  camlhmp_version params  comment\ncamlhmp I   ccrA1,ccrB1,IS431,IS1272,mecA,mecR1 sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type targets The targets for the given type that had a hit schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result"},{"location":"#example-prefixblasttsv","title":"Example {PREFIX}.blast.tsv","text":"<pre><code>qseqid  sseqid  pident  qcovs   qlen    slen    length  nident  mismatch    gapopen qstart  qend    sstart  send    evalue  bitscore\nccrA1   AB033763.2  100.000 100 1350    39332   1350    1350    0   0   1   1350    23692   25041   0.0 2494\nccrB1   AB033763.2  100.000 100 1152    39332   1152    1152    0   0   1   1152    25063   26214   0.0 2128\nIS1272  AB033763.2  100.000 100 1659    39332   1659    1659    0   0   1   1659    28423   30081   0.0 3064\nmecR1   AB033763.2  100.000 100 987 39332   987 987 0   0   1   987 30304   31290   0.0 1823\nmecA    AB033763.2  99.950  100 2007    39332   2007    2006    1   0   1   2007    31390   33396   0.0 3701\nmecA    AB033763.2  99.950  100 2007    39332   2007    2006    1   0   1   2007    31390   33396   0.0 3701\nIS431   AB033763.2  99.873  100 790 39332   790 789 1   0   1   790 35958   36747   0.0 1454\nIS431   AB033763.2  100.000 100 792 39332   792 792 0   0   1   792 35957   36748   0.0 1463\n</code></pre> <p>This is the standard BLAST output with <code>-outfmt 6</code></p>"},{"location":"#example-prefixdetailstsv","title":"Example {PREFIX}.details.tsv","text":"<pre><code>sample  type    status  targets missing schema  schema_version  camlhmp_version params  comment\ncamlhmp I   True    ccrA1,ccrB1,IS431,mecA,mecR1,IS1272     sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp II  False   IS431,mecA,mecR1    ccrA2,ccrB2,mecI    sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp III False   IS431,mecA,mecR1    ccrA3,ccrB3,mecI    sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp IV  False   IS431,mecA,mecR1,IS1272 ccrA2,ccrB2 sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre> <p>This file provides a detailed view of the results. The columns are:</p> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type status The status of the type (True if failed) targets The targets for the given type that had a match missing The targets for the given type that were not found schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result"},{"location":"#camlhmp-blast-region","title":"<code>camlhmp-blast-region</code>","text":"<p><code>camlhmp-blast-region</code> is a command that allows users to search for full regions of interest. It is nearly identical to <code>camlhmp-blast</code>, but instead of many smaller targets the idea is to instead look at full regions such as O-antigens and or similar features.</p>"},{"location":"#usage_1","title":"Usage","text":"<pre><code> Usage: camlhmp-blast-region [OPTIONS]\n\n \ud83d\udc2a camlhmp-blast-region \ud83d\udc2a - Classify assemblies with a camlhmp schema using BLAST against\n larger genomic regions\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --input         -i  TEXT     Input file in FASTA format to classify [required]           \u2502\n\u2502 *  --yaml          -y  TEXT     YAML file documenting the targets and types [required]      \u2502\n\u2502 *  --targets       -t  TEXT     Query targets in FASTA format [required]                    \u2502\n\u2502    --outdir        -o  PATH     Directory to write output [default: ./]                     \u2502\n\u2502    --prefix        -p  TEXT     Prefix to use for output files [default: camlhmp]           \u2502\n\u2502    --min-pident        INTEGER  Minimum percent identity to count a hit [default: 95]       \u2502\n\u2502    --min-coverage      INTEGER  Minimum percent coverage to count a hit [default: 95]       \u2502\n\u2502    --force                      Overwrite existing reports                                  \u2502\n\u2502    --verbose                    Increase the verbosity of output                            \u2502\n\u2502    --silent                     Only critical errors will be printed                        \u2502\n\u2502    --version       -V           Print schema and camlhmp version                            \u2502\n\u2502    --help                       Show this message and exit.                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"#output-files_1","title":"Output Files","text":"<p><code>camlhmp-blast-region</code> will generate three output files:</p> File Name Description <code>{PREFIX}.tsv</code> A tab-delimited file with the predicted type <code>{PREFIX}.blast.tsv</code> A tab-delimited file of all blast hits <code>{PREFIX}.details.tsv</code> A tab-delimited file with details for each type"},{"location":"#example-prefixtsv_1","title":"Example {PREFIX}.tsv","text":"<pre><code>sample  type    targets coverage    hits    schema  schema_version  camlhmp_version params  comment\ncamlhmp O5  O2  100.00  1   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type targets The targets for the given type that had a hit coverage The coverage of the target region hits The number of hits used to calculate coverage of the target region schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result"},{"location":"#example-prefixblasttsv_1","title":"Example {PREFIX}.blast.tsv","text":"<pre><code>qseqid  sseqid  pident  qcovs   qlen    slen    length  nident  mismatch    gapopen qstart  qend    sstart  send    evalue  bitscore\nwzyB    NZ_PSQS01000003.1   88.403  99  1140    6935329 595 526 69  0   545 1139    6874509 6875103 0.0 717\nwzyB    NZ_PSQS01000003.1   88.403  99  1140    6935329 595 526 69  0   545 1139    6920911 6921505 0.0 717\nwzyB    NZ_PSQS01000003.1   89.444  99  1140    6935329 540 483 56  1   1   539 6872864 6873403 0.0 680\nwzyB    NZ_PSQS01000003.1   89.444  99  1140    6935329 540 483 56  1   1   539 6919266 6919805 0.0 680\nO1  NZ_PSQS01000003.1   97.972  12  18368   6935329 1972    1932    38  2   16398   18368   6620589 6618619 0.0 3419\nO1  NZ_PSQS01000003.1   96.296  12  18368   6935329 324 312 11  1   1   323 6641914 6641591 1.68e-149   531\nO2  NZ_PSQS01000003.1   99.841  100 23303   6935329 23303   23266   30  1   1   23303   6618619 6641914 0.0 42821\nO2  NZ_PSQS01000003.1   86.935  100 23303   6935329 1240    1078    130 12  2542    3749    3864567 3863328 0.0 1363\nO3  NZ_PSQS01000003.1   94.442  13  20210   6935329 2393    2260    114 15  1   2386    6618619 6620999 0.0 3664\nO3  NZ_PSQS01000003.1   99.308  13  20210   6935329 289 287 2   0   19922   20210   6641626 6641914 3.09e-147   523\nO4  NZ_PSQS01000003.1   97.448  14  15279   6935329 1842    1795    47  0   1   1842    6618619 6620460 0.0 3142\nO4  NZ_PSQS01000003.1   99.638  14  15279   6935329 276 275 1   0   15004   15279   6641639 6641914 8.46e-142   505\n</code></pre> <p>This is the standard BLAST output with <code>-outfmt 6</code></p>"},{"location":"#example-prefixdetailstsv_1","title":"Example {PREFIX}.details.tsv","text":"<pre><code>sample  type    status  targets missing coverage    hits    schema  schema_version  camlhmp_version params  comment\ncamlhmp O1  False       O1  12.49   2   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   Coverage based on 2 hits\ncamlhmp O2  False   O2  wzyB    100.00,0.00 1,0 pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp O3  False       O3  1.43    1   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp O4  False       O4  13.86   2   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   Coverage based on 2 hits\ncamlhmp O5  True    O2      100.00  1   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre> <p>This file provides a detailed view of the results. The columns are:</p> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type status The status of the type (True if failed) targets The targets for the given type that had a match missing The targets for the given type that were not found coverage The coverage of the target region hits The number of hits used to calculate coverage of the target region schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result"},{"location":"#camlhmp-extract","title":"<code>camlhmp-extract</code>","text":"<p><code>camlhmp-extract</code> is a command that allows users to extract targets from a set of references. You should think of this script as a \"helper\" script for curators. It allows you to maintain a TSV file with the targets and their positions in the reference sequences. <code>camlhmp-extract</code> will then extract the targets from the reference sequences and write them to a FASTA file.</p>"},{"location":"#usage_2","title":"Usage","text":"<pre><code> \ud83d\udc2a camlhmp-extract \ud83d\udc2a - Extract typing targets from a set of reference sequences\n\n\u256d\u2500 Required Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --path     -i  TEXT  The path where input files are located [required]                   \u2502\n\u2502 *  --targets  -t  TEXT  A TSV of targets to extract in FASTA format [required]              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Additional Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --outdir   -o  TEXT  The path to save the extracted targets                                 \u2502\n\u2502 --verbose            Increase the verbosity of output                                       \u2502\n\u2502 --silent             Only critical errors will be printed                                   \u2502\n\u2502 --version  -V        Show the version and exit.                                             \u2502\n\u2502 --help               Show this message and exit.                                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"#citations","title":"Citations","text":"<p>If you make use of this tool, please cite the following:</p> <ul> <li> <p>camlhmp Petit III RA camlhmp: Classification through yAML Heuristic Mapping Protocol (GitHub) </p> </li> <li> <p>BLAST__ Basic Local Alignment Search Tool _Camacho C, Coulouris G, Avagyan V, Ma N, Papadopoulos J, Bealer K, Madden TL BLAST+: architecture and applications. BMC Bioinformatics 10, 421 (2009) </p> </li> </ul>"},{"location":"#naming","title":"Naming","text":"<p>If I'm being honest, I really wanted to name a tool with \"camel\" in it because they are my wife's favorite animal\ud83d\udc2a and they also remind me of my friends in Oman!</p> <p>Once it was decided YAML was going to be the format for defining schemas, I quickly stumbled on \"Classification through YAML\" and quickly found out I wasn't the only once who thought of \"CAML\". But, no matter, it was decided it would be something with \"CAML\", then Tim Read came with the save and suggested \"Heuristic Mapping Protocol\". So, here we are - camlhmp!</p>"},{"location":"#license","title":"License","text":"<p>I'm not a lawyer and MIT has always been my go-to license. So, MIT it is!</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#camlhmp","title":"camlhmp","text":"<p>\ud83d\udc2a camlhmp \ud83d\udc2a - Classification through yAML Heuristic Mapping Protocol</p> <p><code>camlhmp</code> is a tool for generating organism typing tools from YAML schemas. The idea came up from discussions with Tim Read about the need for a tool that would allow researchers to more easily define typing schemas for their organisms of interest. YAML seemed like a a nice format for this due to its simplicity and readability.</p> <p><code>camlhmp</code> is under active development, and any feedback is appreciated.</p>"},{"location":"installation/#purpose","title":"Purpose","text":"<p>The primary purpose of <code>camlhmp</code> is to provide a framework that enables researchers to independently define typing schemas for their organisms of interest using YAML. This facilitates the management and analysis biological data, no matter the researchers experience level.</p> <p><code>camlhmp</code> does not supply any pre-defined typing schemas. Instead, it provides researchers with the tools necessary tools to create and maintain their own schemas. This I believe will ensure the schemas remain up to date with the latest developments in its respective field.</p> <p>Additionally, this really arose from a practical need to streamline my maintenance of multiple organism typing tools. Long-term maintenance of these tools is a challenge, and I think <code>camlhmp</code> will help me to keep them up-to-date and consistent.</p>"},{"location":"installation/#installation","title":"Installation","text":"<p><code>camlhmp</code> will be made available through PyPI and Bioconda. For now, you can install it from the GitHub repository with the following command:</p> <pre><code>conda create -n camlhmp -c conda-forge -c bioconda camlhmp\nconda activate camlhmp\ncamlhmp\n</code></pre>"},{"location":"installation/#yaml-schema-structure","title":"YAML Schema Structure","text":"<p>The schema structure is designed to be simple and intuitive. Here is a basic skeleton of the expected schema structure:</p> <pre><code>%YAML 1.2\n---\n# metadata: general information about the schema\nmetadata:\n  id: \"\"          # unique identifier for the schema\n  name: \"\"        # name of the schema\n  description: \"\" # description of the schema\n  version: \"\"     # version of the schema\n  curators: []    # A list of curators of the schema\n\n# engine: specifies the computational tools and additional parameters used for sequence\n#         analysis.\nengine:\n  tool: \"\" # The tool used to generate the data\n\n# targets: Lists the specific sequence targets such as genes, proteins, or markers that the\n#          schema will analyze. These should be included in the associated sequence query data\ntargets: []\n\n# aliases: groups multiple targets under a common name for easier reference\naliases:\n  - name: \"\"     # name of the alias\n    targets: []  # list of targets that are part of the alias\n\n# types: define specific combinations of targets and aliases to form distinct types\ntypes:\n  - name: \"\"     # name of the profile\n    targets: []  # list of targets (can use aliases) that are part of the profile\n    excludes: [] # list of targets (or aliases) that will automatically fail the type\n</code></pre> <p>From this schema we have a few sections:</p> <ul> <li><code>metadata</code>: general information about the schema</li> <li><code>engine</code>: computational requirements for sequence analysis</li> <li><code>targets</code>: lists the sequence targets such as genes, proteins, or markers</li> <li><code>aliases</code>: groups multiple targets under a common name for easier reference</li> <li><code>profiles</code>: defines combinations of targets and aliases to form typing profiles</li> </ul> <p>Within each section there are additional fields that will be descibed in the next sections.</p>"},{"location":"installation/#metadata","title":"metadata","text":"<p>The <code>metadata</code> section provides general information about the schema. This includes:</p> Field Type Description id string A unique identifier for the schema name string The name of the schema description string A brief description of the schema version string The version of the schema curators list A list of curators of the schema"},{"location":"installation/#engine","title":"engine","text":"<p>The <code>engine</code> section specifies the computational tools used for sequence analysis. Currently only one tool can be specified, and only <code>blastn</code> is supported.</p> Field Type Description tool string The tool used to generate the data"},{"location":"installation/#targets","title":"targets","text":"<p>The <code>targets</code> section lists the specific sequence targets such as genes, proteins, or markers that the schema will analyze. These should be included in the associated sequence query data.</p> Field Type Description targets list A list of targets to be analyzed"},{"location":"installation/#aliases","title":"aliases","text":"<p><code>aliases</code> are a convenient way to group multiple targets under a common name for easier reference.</p> Field Type Description name string The name of the alias targets list A list of targets that are part of the alias"},{"location":"installation/#types","title":"types","text":"<p>The <code>types</code> section defines specific combinations of targets and aliases to form distinct types.</p> Field Type Description name string The name of the profile targets list A list of targets (or aliases) that are part of the type excludes list A list of targets (or aliases) that will automatically fail the type"},{"location":"installation/#example-schema-partial-sccmec-typing","title":"Example Schema: Partial SCCmec Typing","text":"<p>Here is an example of a partial schema for SCCmec typing:</p> <pre><code>%YAML 1.2\n---\n# metadata: general information about the schema\nmetadata:\n  id: \"sccmec_partial\"                                # unique identifier for the schema\n  name: \"SCCmec Typing\"                              # name of the schema\n  description: \"A partial schema for SCCmec typing\"  # description of the schema\n  version: \"0.0.1\"                                     # version of the schema\n  curators:                                          # A list of curators of the schema\n    - \"Robert Petit\"\n\n# engine: specifies the computational tools and additional parameters used for sequence\n#         analysis.\nengine:\n  tool: blastn # The tool used to generate the data\n\n# targets: Lists the specific sequence targets such as genes, proteins, or markers that the\n#          schema will analyze. These should be included in the associated sequence query data\ntargets:\n  - \"ccrA1\"\n  - \"ccrA2\"\n  - \"ccrA3\"\n  - \"ccrB1\"\n  - \"ccrB2\"\n  - \"ccrB3\"\n  - \"IS431\"\n  - \"IS1272\"\n  - \"mecA\"\n  - \"mecI\"\n  - \"mecR1\"\n\n# aliases: groups multiple targets under a common name for easier reference\naliases:\n  - name: \"ccr Type 1\"           # name of the alias\n    targets: [\"ccrA1\", \"ccrB1\"]  # list of targets that are part of the alias\n  - name: \"ccr Type 2\"\n    targets: [\"ccrA2\", \"ccrB2\"]\n  - name: \"ccr Type 3\"\n    targets: [\"ccrA3\", \"ccrB3\"]\n  - name: \"mec Class A\"\n    targets: [\"IS431\", \"mecA\", \"mecR1\", \"mecI\"]\n  - name: \"mec Class B\"\n    targets: [\"IS431\", \"mecA\", \"mecR1\", \"IS1272\"]\n\n# types: define specific combinations of targets and aliases to form distinct types\ntypes:\n  - name: \"I\"          # name of the profile\n    targets:           # list of targets (can use aliases) that are part of the profile\n      - \"ccr Type 1\"\n      - \"mec Class B\"\n  - name: \"II\"\n    targets:\n      - \"ccr Type 2\"\n      - \"mec Class A\"\n  - name: \"III\"\n    targets:\n      - \"ccr Type 3\"\n      - \"mec Class A\"\n  - name: \"IV\"\n    targets:\n      - \"ccr Type 2\"\n      - \"mec Class B\"\n</code></pre> <p>From this schema, <code>camlhmp</code> can generate a typing tool that can be used to analyze input assemblies. This is only a partial schema, as there are many more SCCmec types and subtypes. But using this schema it should be straight forward to add additional targets and profiles.</p>"},{"location":"installation/#camlhmp-blast","title":"<code>camlhmp-blast</code>","text":"<p><code>camlhmp-blast</code> is a command that allows users to type their samples using a provided schema with BLAST algorithms.</p>"},{"location":"installation/#usage","title":"Usage","text":"<pre><code> \ud83d\udc2a camlhmp-blast \ud83d\udc2a - Classify assemblies with a camlhmp schema using BLAST                          \n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502    --version       -V           Show the version and exit.                                  \u2502\n\u2502 *  --input         -i  TEXT     Input file in FASTA format to classify [required]           \u2502\n\u2502 *  --yaml          -y  TEXT     YAML file documenting the targets and types [required]      \u2502\n\u2502 *  --targets       -t  TEXT     Query targets in FASTA format [required]                    \u2502\n\u2502    --outdir        -o  PATH     Directory to write output [default: ./]                     \u2502\n\u2502    --prefix        -p  TEXT     Prefix to use for output files [default: camlhmp]           \u2502\n\u2502    --min-pident        INTEGER  Minimum percent identity to count a hit [default: 95]       \u2502\n\u2502    --min-coverage      INTEGER  Minimum percent coverage to count a hit [default: 95]       \u2502\n\u2502    --force                      Overwrite existing reports                                  \u2502\n\u2502    --verbose                    Increase the verbosity of output                            \u2502\n\u2502    --silent                     Only critical errors will be printed                        \u2502\n\u2502    --help                       Show this message and exit.                                 |\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"installation/#output-files","title":"Output Files","text":"<p><code>camlhmp-blast</code> will generate three output files:</p> File Name Description <code>{PREFIX}.tsv</code> A tab-delimited file with the predicted type <code>{PREFIX}.blast.tsv</code> A tab-delimited file of all blast hits <code>{PREFIX}.details.tsv</code> A tab-delimited file with details for each type"},{"location":"installation/#example-prefixtsv","title":"Example {PREFIX}.tsv","text":"<pre><code>sample  type    targets schema  schema_version  camlhmp_version params  comment\ncamlhmp I   ccrA1,ccrB1,IS431,IS1272,mecA,mecR1 sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type targets The targets for the given type that had a hit schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result"},{"location":"installation/#example-prefixblasttsv","title":"Example {PREFIX}.blast.tsv","text":"<pre><code>qseqid  sseqid  pident  qcovs   qlen    slen    length  nident  mismatch    gapopen qstart  qend    sstart  send    evalue  bitscore\nccrA1   AB033763.2  100.000 100 1350    39332   1350    1350    0   0   1   1350    23692   25041   0.0 2494\nccrB1   AB033763.2  100.000 100 1152    39332   1152    1152    0   0   1   1152    25063   26214   0.0 2128\nIS1272  AB033763.2  100.000 100 1659    39332   1659    1659    0   0   1   1659    28423   30081   0.0 3064\nmecR1   AB033763.2  100.000 100 987 39332   987 987 0   0   1   987 30304   31290   0.0 1823\nmecA    AB033763.2  99.950  100 2007    39332   2007    2006    1   0   1   2007    31390   33396   0.0 3701\nmecA    AB033763.2  99.950  100 2007    39332   2007    2006    1   0   1   2007    31390   33396   0.0 3701\nIS431   AB033763.2  99.873  100 790 39332   790 789 1   0   1   790 35958   36747   0.0 1454\nIS431   AB033763.2  100.000 100 792 39332   792 792 0   0   1   792 35957   36748   0.0 1463\n</code></pre> <p>This is the standard BLAST output with <code>-outfmt 6</code></p>"},{"location":"installation/#example-prefixdetailstsv","title":"Example {PREFIX}.details.tsv","text":"<pre><code>sample  type    status  targets missing schema  schema_version  camlhmp_version params  comment\ncamlhmp I   True    ccrA1,ccrB1,IS431,mecA,mecR1,IS1272     sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp II  False   IS431,mecA,mecR1    ccrA2,ccrB2,mecI    sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp III False   IS431,mecA,mecR1    ccrA3,ccrB3,mecI    sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp IV  False   IS431,mecA,mecR1,IS1272 ccrA2,ccrB2 sccmec_partial  0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre> <p>This file provides a detailed view of the results. The columns are:</p> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type status The status of the type (True if failed) targets The targets for the given type that had a match missing The targets for the given type that were not found schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result"},{"location":"installation/#camlhmp-blast-region","title":"<code>camlhmp-blast-region</code>","text":"<p><code>camlhmp-blast-region</code> is a command that allows users to search for full regions of interest. It is nearly identical to <code>camlhmp-blast</code>, but instead of many smaller targets the idea is to instead look at full regions such as O-antigens and or similar features.</p>"},{"location":"installation/#usage_1","title":"Usage","text":"<pre><code> Usage: camlhmp-blast-region [OPTIONS]\n\n \ud83d\udc2a camlhmp-blast-region \ud83d\udc2a - Classify assemblies with a camlhmp schema using BLAST against\n larger genomic regions\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --input         -i  TEXT     Input file in FASTA format to classify [required]           \u2502\n\u2502 *  --yaml          -y  TEXT     YAML file documenting the targets and types [required]      \u2502\n\u2502 *  --targets       -t  TEXT     Query targets in FASTA format [required]                    \u2502\n\u2502    --outdir        -o  PATH     Directory to write output [default: ./]                     \u2502\n\u2502    --prefix        -p  TEXT     Prefix to use for output files [default: camlhmp]           \u2502\n\u2502    --min-pident        INTEGER  Minimum percent identity to count a hit [default: 95]       \u2502\n\u2502    --min-coverage      INTEGER  Minimum percent coverage to count a hit [default: 95]       \u2502\n\u2502    --force                      Overwrite existing reports                                  \u2502\n\u2502    --verbose                    Increase the verbosity of output                            \u2502\n\u2502    --silent                     Only critical errors will be printed                        \u2502\n\u2502    --version       -V           Print schema and camlhmp version                            \u2502\n\u2502    --help                       Show this message and exit.                                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"installation/#output-files_1","title":"Output Files","text":"<p><code>camlhmp-blast-region</code> will generate three output files:</p> File Name Description <code>{PREFIX}.tsv</code> A tab-delimited file with the predicted type <code>{PREFIX}.blast.tsv</code> A tab-delimited file of all blast hits <code>{PREFIX}.details.tsv</code> A tab-delimited file with details for each type"},{"location":"installation/#example-prefixtsv_1","title":"Example {PREFIX}.tsv","text":"<pre><code>sample  type    targets coverage    hits    schema  schema_version  camlhmp_version params  comment\ncamlhmp O5  O2  100.00  1   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type targets The targets for the given type that had a hit coverage The coverage of the target region hits The number of hits used to calculate coverage of the target region schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result"},{"location":"installation/#example-prefixblasttsv_1","title":"Example {PREFIX}.blast.tsv","text":"<pre><code>qseqid  sseqid  pident  qcovs   qlen    slen    length  nident  mismatch    gapopen qstart  qend    sstart  send    evalue  bitscore\nwzyB    NZ_PSQS01000003.1   88.403  99  1140    6935329 595 526 69  0   545 1139    6874509 6875103 0.0 717\nwzyB    NZ_PSQS01000003.1   88.403  99  1140    6935329 595 526 69  0   545 1139    6920911 6921505 0.0 717\nwzyB    NZ_PSQS01000003.1   89.444  99  1140    6935329 540 483 56  1   1   539 6872864 6873403 0.0 680\nwzyB    NZ_PSQS01000003.1   89.444  99  1140    6935329 540 483 56  1   1   539 6919266 6919805 0.0 680\nO1  NZ_PSQS01000003.1   97.972  12  18368   6935329 1972    1932    38  2   16398   18368   6620589 6618619 0.0 3419\nO1  NZ_PSQS01000003.1   96.296  12  18368   6935329 324 312 11  1   1   323 6641914 6641591 1.68e-149   531\nO2  NZ_PSQS01000003.1   99.841  100 23303   6935329 23303   23266   30  1   1   23303   6618619 6641914 0.0 42821\nO2  NZ_PSQS01000003.1   86.935  100 23303   6935329 1240    1078    130 12  2542    3749    3864567 3863328 0.0 1363\nO3  NZ_PSQS01000003.1   94.442  13  20210   6935329 2393    2260    114 15  1   2386    6618619 6620999 0.0 3664\nO3  NZ_PSQS01000003.1   99.308  13  20210   6935329 289 287 2   0   19922   20210   6641626 6641914 3.09e-147   523\nO4  NZ_PSQS01000003.1   97.448  14  15279   6935329 1842    1795    47  0   1   1842    6618619 6620460 0.0 3142\nO4  NZ_PSQS01000003.1   99.638  14  15279   6935329 276 275 1   0   15004   15279   6641639 6641914 8.46e-142   505\n</code></pre> <p>This is the standard BLAST output with <code>-outfmt 6</code></p>"},{"location":"installation/#example-prefixdetailstsv_1","title":"Example {PREFIX}.details.tsv","text":"<pre><code>sample  type    status  targets missing coverage    hits    schema  schema_version  camlhmp_version params  comment\ncamlhmp O1  False       O1  12.49   2   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   Coverage based on 2 hits\ncamlhmp O2  False   O2  wzyB    100.00,0.00 1,0 pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp O3  False       O3  1.43    1   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \ncamlhmp O4  False       O4  13.86   2   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   Coverage based on 2 hits\ncamlhmp O5  True    O2      100.00  1   pseudomonas_serogroup_partial   0.0.1   0.2.1   min-coverage=95;min-pident=95   \n</code></pre> <p>This file provides a detailed view of the results. The columns are:</p> Column Description sample The sample name as determined by <code>--prefix</code> type The predicted type status The status of the type (True if failed) targets The targets for the given type that had a match missing The targets for the given type that were not found coverage The coverage of the target region hits The number of hits used to calculate coverage of the target region schema The schema used to determine the type schema_version The version of the schema used camlhmp_version The version of camlhmp used params The parameters used for the analysis comment A small comment about the result"},{"location":"installation/#camlhmp-extract","title":"<code>camlhmp-extract</code>","text":"<p><code>camlhmp-extract</code> is a command that allows users to extract targets from a set of references. You should think of this script as a \"helper\" script for curators. It allows you to maintain a TSV file with the targets and their positions in the reference sequences. <code>camlhmp-extract</code> will then extract the targets from the reference sequences and write them to a FASTA file.</p>"},{"location":"installation/#usage_2","title":"Usage","text":"<pre><code> \ud83d\udc2a camlhmp-extract \ud83d\udc2a - Extract typing targets from a set of reference sequences\n\n\u256d\u2500 Required Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --path     -i  TEXT  The path where input files are located [required]                   \u2502\n\u2502 *  --targets  -t  TEXT  A TSV of targets to extract in FASTA format [required]              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Additional Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --outdir   -o  TEXT  The path to save the extracted targets                                 \u2502\n\u2502 --verbose            Increase the verbosity of output                                       \u2502\n\u2502 --silent             Only critical errors will be printed                                   \u2502\n\u2502 --version  -V        Show the version and exit.                                             \u2502\n\u2502 --help               Show this message and exit.                                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"installation/#citations","title":"Citations","text":"<p>If you make use of this tool, please cite the following:</p> <ul> <li> <p>camlhmp Petit III RA camlhmp: Classification through yAML Heuristic Mapping Protocol (GitHub) </p> </li> <li> <p>BLAST__ Basic Local Alignment Search Tool _Camacho C, Coulouris G, Avagyan V, Ma N, Papadopoulos J, Bealer K, Madden TL BLAST+: architecture and applications. BMC Bioinformatics 10, 421 (2009) </p> </li> </ul>"},{"location":"installation/#naming","title":"Naming","text":"<p>If I'm being honest, I really wanted to name a tool with \"camel\" in it because they are my wife's favorite animal\ud83d\udc2a and they also remind me of my friends in Oman!</p> <p>Once it was decided YAML was going to be the format for defining schemas, I quickly stumbled on \"Classification through YAML\" and quickly found out I wasn't the only once who thought of \"CAML\". But, no matter, it was decided it would be something with \"CAML\", then Tim Read came with the save and suggested \"Heuristic Mapping Protocol\". So, here we are - camlhmp!</p>"},{"location":"installation/#license","title":"License","text":"<p>I'm not a lawyer and MIT has always been my go-to license. So, MIT it is!</p>"},{"location":"api/engines/blast/","title":"Blast","text":""},{"location":"api/engines/blast/#camlhmp.engines.blast.run_blast","title":"<code>camlhmp.engines.blast.run_blast(engine, subject, query, min_pident, min_coverage)</code>","text":"<p>Query sequences against a input subject using BLAST+.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>str</code> <p>The BLAST engine to use</p> required <code>subject</code> <code>str</code> <p>The subject database (input)</p> required <code>query</code> <code>str</code> <p>The query file (targets)</p> required <code>min_pident</code> <code>float</code> <p>The minimum percent identity to count a hit</p> required <code>min_coverage</code> <code>int</code> <p>The minimum percent coverage to count a hit</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>The parsed BLAST results, raw blast results, and stderr</p> Source code in <code>camlhmp/engines/blast.py</code> <pre><code>def run_blast(engine: str, subject: str, query: str, min_pident: float, min_coverage: int) -&gt; list:\n    \"\"\"\n    Query sequences against a input subject using BLAST+.\n\n    Args:\n        engine (str): The BLAST engine to use\n        subject (str): The subject database (input)\n        query (str): The query file (targets)\n        min_pident (float): The minimum percent identity to count a hit\n        min_coverage (int): The minimum percent coverage to count a hit\n\n    Returns:\n        list: The parsed BLAST results, raw blast results, and stderr\n    \"\"\"\n    outfmt = \" \".join(BLASTN_COLS)\n    cat_type = \"zcat\" if str(subject).endswith(\".gz\") else \"cat\"\n    qcov_hsp_perc = f\"-qcov_hsp_perc {min_coverage}\" if min_coverage else \"\"\n    perc_identity = f\"-perc_identity {min_pident}\" if min_pident and engine != \"tblastn\" else \"\"\n    stdout, stderr = execute(\n        f\"{cat_type} {subject} | {engine} -query {query} -subject - -outfmt '6 {outfmt}' {qcov_hsp_perc} {perc_identity}\",\n        capture=True,\n    )\n\n    # Convert BLAST results to a list of dicts\n    results = []\n    target_hits = []\n    for line in stdout.split(\"\\n\"):\n        if line == \"\":\n            continue\n        cols = line.split(\"\\t\")\n        results.append(dict(zip(BLASTN_COLS, cols)))\n        target_hits.append(cols[0])\n\n    if not results:\n        # Create an empty dict if no results are found\n        results.append(dict(zip(BLASTN_COLS, [\"NO_HITS\"] * len(BLASTN_COLS))))\n\n    return [target_hits, results, stderr]\n</code></pre>"},{"location":"api/engines/blast/#camlhmp.engines.blast.run_blastn","title":"<code>camlhmp.engines.blast.run_blastn(subject, query, min_pident, min_coverage)</code>","text":"<p>Query sequences against a input subject using BLASTN.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject database (input)</p> required <code>query</code> <code>str</code> <p>The query file (targets)</p> required <code>min_pident</code> <code>float</code> <p>The minimum percent identity to count a hit</p> required <code>min_coverage</code> <code>int</code> <p>The minimum percent coverage to count a hit</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>The parsed BLAST results, raw blast results, and stderr</p> Source code in <code>camlhmp/engines/blast.py</code> <pre><code>def run_blastn(subject: str, query: str, min_pident: float, min_coverage: int) -&gt; list:\n    \"\"\"\n    Query sequences against a input subject using BLASTN.\n\n    Args:\n        subject (str): The subject database (input)\n        query (str): The query file (targets)\n        min_pident (float): The minimum percent identity to count a hit\n        min_coverage (int): The minimum percent coverage to count a hit\n\n    Returns:\n        list: The parsed BLAST results, raw blast results, and stderr\n    \"\"\"\n    return run_blast(\"blastn\", subject, query, min_pident, min_coverage)\n</code></pre>"},{"location":"api/engines/blast/#camlhmp.engines.blast.run_tblastn","title":"<code>camlhmp.engines.blast.run_tblastn(subject, query, min_pident, min_coverage)</code>","text":"<p>Query sequences against a input subject using TBLASTN.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>The subject database (input)</p> required <code>query</code> <code>str</code> <p>The query file (targets)</p> required <code>min_pident</code> <code>float</code> <p>The minimum percent identity to count a hit</p> required <code>min_coverage</code> <code>int</code> <p>The minimum percent coverage to count a hit</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>The parsed BLAST results, raw blast results, and stderr</p> Source code in <code>camlhmp/engines/blast.py</code> <pre><code>def run_tblastn(subject: str, query: str, min_pident: float, min_coverage: int) -&gt; list:\n    \"\"\"\n    Query sequences against a input subject using TBLASTN.\n\n    Args:\n        subject (str): The subject database (input)\n        query (str): The query file (targets)\n        min_pident (float): The minimum percent identity to count a hit\n        min_coverage (int): The minimum percent coverage to count a hit\n\n    Returns:\n        list: The parsed BLAST results, raw blast results, and stderr\n    \"\"\"\n    return run_blast(\"tblastn\", subject, query, min_pident, min_coverage)\n</code></pre>"},{"location":"api/parsers/blast/","title":"Blast","text":""},{"location":"api/parsers/blast/#get_blast_allele_hits","title":"<code>get_blast_allele_hits</code>","text":""},{"location":"api/parsers/blast/#camlhmp.parsers.blast.get_blast_allele_hits","title":"<code>camlhmp.parsers.blast.get_blast_allele_hits(targets, results, min_pident, min_coverage)</code>","text":"<p>Find the allele hits in the BLAST results.</p> <p>Parameters:</p> Name Type Description Default <code>targets</code> <code>dict</code> <p>The list of target sequences {id: len(seq)}</p> required <code>results</code> <code>list of dict</code> <p>The BLAST results</p> required <code>min_pident</code> <code>float</code> <p>The minimum percent identity to count a hit</p> required <code>min_coverage</code> <code>int</code> <p>The minimum percent coverage to count a hit</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The allele hits</p> Source code in <code>camlhmp/parsers/blast.py</code> <pre><code>def get_blast_allele_hits(\n    targets: dict, results: dict, min_pident: float, min_coverage: int\n) -&gt; dict:\n    \"\"\"\n    Find the allele hits in the BLAST results.\n\n    Args:\n        targets (dict): The list of target sequences {id: len(seq)}\n        results (list of dict): The BLAST results\n        min_pident (float): The minimum percent identity to count a hit\n        min_coverage (int): The minimum percent coverage to count a hit\n\n    Returns:\n        dict: The allele hits\n    \"\"\"\n    # Aggregate the hits for each target\n    target_results = {}\n\n    for result in results:\n        # Only process real hits\n        if result[\"qseqid\"] != \"NO_HITS\":\n            target, allele = result[\"qseqid\"].rsplit(\"_\", 1)\n            if target not in target_results:\n                target_results[target] = {\n                    \"known\": [],\n                    \"novel\": [],\n                }\n\n            # only process hits that meet minimum criteria\n            if float(result[\"pident\"]) &gt;= min_pident and int(result[\"qcovs\"]) &gt;= min_coverage:\n                # hits that meet requirements\n\n                # Default to \"NEW\" allele, if perfect match use the allele ID\n                final_allele = \"NEW\"\n                final_type = \"novel\"\n                if float(result[\"pident\"]) == 100 and int(result[\"qcovs\"]) == 100:\n                    final_allele = allele\n                    final_type = \"known\"\n\n                target_results[target][final_type].append({\n                        \"id\": final_allele,\n                        \"qcovs\": result[\"qcovs\"],\n                        \"pident\": float(result[\"pident\"]),\n                        \"bitscore\": result[\"bitscore\"],\n                })\n\n    final_allele_hits = {}\n    for target in targets:\n        final_allele_hits[target] = {\n            \"id\": \"-\",\n            \"qcovs\": 0,\n            \"pident\": 0,\n            \"bitscore\": 0,\n            \"comment\": \"No hits met thresholds\",\n        }\n\n    for target in target_results:\n        if len(target_results[target][\"known\"]):\n            # exact matches to known alleles were found\n            if len(target_results[target][\"known\"]) == 1:\n                final_allele_hits[target] = target_results[target][\"known\"][0]\n                final_allele_hits[target][\"comment\"] = \"\"\n            else:\n                # multiple hits\n                final_alleles = []\n                for hit in target_results[target][\"known\"]:\n                    final_alleles.append(hit[\"id\"])\n\n                final_allele_hits[target] = target_results[target][\"known\"][0]\n                final_allele_hits[target][\"id\"] = \",\".join(final_alleles)\n                final_allele_hits[target][\"comment\"] = \"Exact matches to multiple alleles\"\n        elif len(target_results[target][\"novel\"]):\n            # no exact matches to known alleles were found, but thresholds were met\n\n            # report the top scores\n            if len(target_results[target][\"novel\"]) == 1:\n                final_allele_hits[target] = target_results[target][\"novel\"][0]\n                final_allele_hits[target][\"comment\"] = \"\"\n            else:\n                # multiple hits, only report highest score\n                final_allele_hits[target] = sorted(target_results[target][\"novel\"], key=lambda x: x[\"bitscore\"], reverse=True)[0]\n                final_allele_hits[target][\"comment\"] = \"No exact matches to known alleles\"\n\n    # Debugging information\n    logging.debug(\"camlhmp.engines.blast.get_blast_allele_hits\")\n    logging.debug(f\"Allele Hits: {final_allele_hits}\")\n\n    return final_allele_hits\n</code></pre>"},{"location":"api/parsers/blast/#get_blast_region_hits","title":"<code>get_blast_region_hits</code>","text":""},{"location":"api/parsers/blast/#camlhmp.parsers.blast.get_blast_region_hits","title":"<code>camlhmp.parsers.blast.get_blast_region_hits(targets, results, min_pident, min_coverage)</code>","text":"<p>Aggregate multiple target hits for a region from the BLAST results.</p> <p>Parameters:</p> Name Type Description Default <code>targets</code> <code>dict</code> <p>The list of target sequences {id: len(seq)}</p> required <code>results</code> <code>list of dict</code> <p>The BLAST results</p> required <code>min_pident</code> <code>float</code> <p>The minimum percent identity to count a hit</p> required <code>min_coverage</code> <code>int</code> <p>The minimum percent coverage to count a hit</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The target hits</p> Source code in <code>camlhmp/parsers/blast.py</code> <pre><code>def get_blast_region_hits(\n    targets: dict, results: dict, min_pident: float, min_coverage: int\n) -&gt; dict:\n    \"\"\"\n    Aggregate multiple target hits for a region from the BLAST results.\n\n    Args:\n        targets (dict): The list of target sequences {id: len(seq)}\n        results (list of dict): The BLAST results\n        min_pident (float): The minimum percent identity to count a hit\n        min_coverage (int): The minimum percent coverage to count a hit\n\n    Returns:\n        dict: The target hits\n    \"\"\"\n    # Aggregate the hits for each target\n    target_results = {}\n    for target, length in targets.items():\n        target_results[target] = {\n            \"hits\": [],\n            \"coverage\": [0] * length,  # Used to calculate coverage across multiple hits\n            \"comment\": [],\n        }\n\n    # Process each blast hit\n    for result in results:\n        # Only process real hits\n        if result[\"qseqid\"] != \"NO_HITS\":\n            # Only keep hits that pass the minimum percent identity\n            if float(result[\"pident\"]) &gt;= min_pident:\n                # Add hit to list of hits\n                target_results[result[\"qseqid\"]][\"hits\"].append(result)\n\n                # Set the coverage to 1 for each base in the hit\n                for i in range(int(result[\"qstart\"]) - 1, int(result[\"qend\"])):\n                    target_results[result[\"qseqid\"]][\"coverage\"][i] += 1\n\n    # Determine coverage for each target\n    final_results = {}\n    for target, vals in target_results.items():\n        final_results[target] = {\n            \"hits\": vals[\"hits\"],\n            \"coverage\": 100\n            * (\n                sum([1 for i in vals[\"coverage\"] if i &gt; 0])\n                / float(len(vals[\"coverage\"]))\n            ),\n            \"comment\": [],\n        }\n        if len(vals[\"hits\"]) &gt; 1:\n            final_results[target][\"comment\"].append(\n                f\"Coverage based on {len(vals['hits'])} hits\"\n            )\n\n        if sum([1 for i in vals[\"coverage\"] if i &gt; 1]):\n            final_results[target][\"comment\"].append(\n                \"There were one or more overlapping hits\"\n            )\n\n    # Debugging information\n    logging.debug(\"camlhmp.engines.blast_region.get_blast_region_hits\")\n    logging.debug(f\"Profile Hits: {final_results}\")\n\n    return final_results\n</code></pre>"},{"location":"api/parsers/blast/#get_blast_target_hits","title":"<code>get_blast_target_hits</code>","text":""},{"location":"api/parsers/blast/#camlhmp.parsers.blast.get_blast_target_hits","title":"<code>camlhmp.parsers.blast.get_blast_target_hits(targets, results)</code>","text":"<p>Find the target hits in the BLAST results.</p> <p>Parameters:</p> Name Type Description Default <code>targets</code> <code>list</code> <p>The list of target sequences</p> required <code>results</code> <code>dict</code> <p>The BLAST results</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The target hits</p> Source code in <code>camlhmp/parsers/blast.py</code> <pre><code>def get_blast_target_hits(targets: list, results: dict) -&gt; dict:\n    \"\"\"\n    Find the target hits in the BLAST results.\n\n    Args:\n        targets (list): The list of target sequences\n        results (dict): The BLAST results\n\n    Returns:\n        dict: The target hits\n    \"\"\"\n    target_hits = {}\n    for target in targets:\n        target_hits[target] = False\n        if target in results:\n            target_hits[target] = True\n\n    # Debugging information\n    logging.debug(\"camlhmp.engines.blast.get_blast_target_hits\")\n    logging.debug(f\"Profile Hits: {target_hits}\")\n\n    return target_hits\n</code></pre>"}]}